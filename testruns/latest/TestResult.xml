<?xml version="1.0" encoding="utf-8" standalone="no"?>
<test-run id="2" testcasecount="185" result="Passed" total="185" passed="185" failed="0" inconclusive="0" skipped="0" asserts="1938" engine-version="3.10.0.0" clr-version="4.0.30319.42000" start-time="2020-05-03 00:09:23Z" end-time="2020-05-03 00:09:25Z" duration="2.673850">
  <command-line><![CDATA["C:\ProgramData\chocolatey\lib\nunit-console-runner\tools\nunit3-console.exe" ..\..\src\Testing\Specflow\bin\Debug\Testing.Specflow.dll --result=report.txt;transform=..\..\..\nunit-transforms\nunit3-summary\text-report.xslt --result=report.html;transform=..\..\..\nunit-transforms\nunit3-summary\html-report.xslt --result=readme.md;transform=..\md-report.xslt --result=TestResult.xml]]></command-line>
  <test-suite type="Assembly" id="0-1200" name="Testing.Specflow.dll" fullname="F:\src\BenedictionGame\src\Testing\Specflow\bin\Debug\Testing.Specflow.dll" runstate="Runnable" testcasecount="185" result="Passed" start-time="2020-05-03 00:09:23Z" end-time="2020-05-03 00:09:24Z" duration="1.226412" total="185" passed="185" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="1938">
    <environment framework-version="3.12.0.0" clr-version="4.0.30319.42000" os-version="Microsoft Windows NT 10.0.17763.0" platform="Win32NT" cwd="F:\src\BenedictionGame\testruns\latest" machine-name="SPENCER-VR" user="Oculus Rift" user-domain="SPENCER-VR" culture="en-US" uiculture="en-US" os-architecture="x64" />
    <settings>
      <setting name="DisposeRunners" value="True" />
      <setting name="WorkDirectory" value="F:\src\BenedictionGame\testruns\latest" />
      <setting name="ImageRuntimeVersion" value="4.0.30319" />
      <setting name="ImageTargetFrameworkName" value=".NETFramework,Version=v4.7.1" />
      <setting name="ImageRequiresX86" value="False" />
      <setting name="ImageRequiresDefaultAppDomainAssemblyResolver" value="False" />
      <setting name="NumberOfTestWorkers" value="12" />
    </settings>
    <properties>
      <property name="_PID" value="18624" />
      <property name="_APPDOMAIN" value="domain-" />
    </properties>
    <test-suite type="SetUpFixture" id="0-1000" name="[default namespace]" fullname="Testing_Specflow_NUnitAssemblyHooks" classname="Testing_Specflow_NUnitAssemblyHooks" runstate="Runnable" testcasecount="185" result="Passed" start-time="2020-05-03 00:09:23Z" end-time="2020-05-03 00:09:24Z" duration="1.210171" total="185" passed="185" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="1938">
      <output><![CDATA[-> Loading plugin F:\src\BenedictionGame\src\Testing\Specflow\bin\Debug\TechTalk.SpecFlow.NUnit.SpecFlowPlugin.dll
-> Using default config
]]></output>
      <test-suite type="TestSuite" id="0-1201" name="Testing" fullname="Testing" runstate="Runnable" testcasecount="185" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.550830" total="185" passed="185" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="1938">
        <test-suite type="TestSuite" id="0-1202" name="Specflow" fullname="Testing.Specflow" runstate="Runnable" testcasecount="185" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.550808" total="185" passed="185" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="1938">
          <test-suite type="TestSuite" id="0-1203" name="Features" fullname="Testing.Specflow.Features" runstate="Runnable" testcasecount="185" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.550803" total="185" passed="185" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="1938">
            <test-suite type="TestSuite" id="0-1205" name="ExampleGames" fullname="Testing.Specflow.Features.ExampleGames" runstate="Runnable" testcasecount="2" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.274866" total="2" passed="2" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="551">
              <test-suite type="TestFixture" id="0-1197" name="AlekSamplesFeature" fullname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature" classname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature" runstate="Runnable" testcasecount="2" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.273970" total="2" passed="2" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="551">
                <properties>
                  <property name="Description" value="Alek Samples" />
                  <property name="Category" value="scenario-image-only" />
                </properties>
                <test-case id="0-1198" name="AlekSampleGame1" fullname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature.AlekSampleGame1" methodname="AlekSampleGame1" classname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature" runstate="Runnable" seed="1950228558" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.209141" asserts="261">
                  <properties>
                    <property name="Description" value="Alek Sample Game 1" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the following moves are performed:
  --- table step argument ---
  | RedAction1 | RedAction2 | BlueAction1 | BlueAction2 |
  | e3e4       | @e3        | f8+f7       | @f8         |
  | d1+d2      | @d1        | d7d6        | @d7         |
  | f1+f2      | @f1        | f7f5        | @f7         |
  | f2f4       | f4-1-f5    | d7+d6       | d6b4        |
  | d2f3       | @f2        | b4b2        | Bc2         |
  | f3h3       | f1+f2      | b2i5        | e9+f8       |
  | h3h5       | h5-1-i5    | @e9         | @d7         |
  | f4g4       | f2f4       | f8h6        | h6-1-i5     |
  | e3+e4      | h5i5       | h6i5        | @f8         |
  | f4d5       | e4e5       | e8+e9       | Bc7         |
  | e1+e2      | e2e4       | f7+e7       | e7e5        |
  | e4e5       | d5e6       | Be7         | @f7         |
  | e5c5       | Ba5        | d8+d7       | @d8         |
  | e6c6       | c6-1-d7    | d8d7        | @d8         |
  | c5b4       | c6d7       |             |             |
Accepted: e3e4
Accepted: @e3
Accepted: f8+f7
Accepted: @f8
Accepted: d1+d2
Accepted: @d1
Accepted: d7d6
Accepted: @d7
Accepted: f1+f2
Accepted: @f1
Accepted: f7f5
Accepted: @f7
Accepted: f2f4
Accepted: f4-1-f5
Accepted: d7+d6
Accepted: d6b4
Accepted: d2f3
Accepted: @f2
Accepted: b4b2
Accepted: Bc2
Accepted: f3h3
Accepted: f1+f2
Accepted: b2i5
Accepted: e9+f8
Accepted: h3h5
Accepted: h5-1-i5
Accepted: @e9
Accepted: @d7
Accepted: f4g4
Accepted: f2f4
Accepted: f8h6
Accepted: h6-1-i5
Accepted: e3+e4
Accepted: h5i5
Accepted: h6i5
Accepted: @f8
Accepted: f4d5
Accepted: e4e5
Accepted: e8+e9
Accepted: Bc7
Accepted: e1+e2
Accepted: e2e4
Accepted: f7+e7
Accepted: e7e5
Accepted: e4e5
Accepted: d5e6
Accepted: Be7
Accepted: @f7
Accepted: e5c5
Accepted: Ba5
Accepted: d8+d7
Accepted: @d8
Accepted: e6c6
Accepted: c6-1-d7
Accepted: d8d7
Accepted: @d8
Accepted: c5b4
Accepted: c6d7
-> done: ActionSteps.WhenTheFollowingMoves(<table>) (0.1s)
Then the following locations match:
  --- table step argument ---
  | Location | Contents | Size | Type   |
  | A5       | Block    |      |        |
  | C7       | Block    |      |        |
  | C2       | Block    |      |        |
  | E7       | Block    |      |        |
  | D1       | Red      | 1    | Normal |
  | B4       | Red      | 2    | King   |
  | D7       | Red      | 1    | Cursed |
  | F5       | Red      | 1    | Cursed |
  | G4       | Red      | 1    | Cursed |
  | D8       | Blue     | 1    | Normal |
  | E9       | Blue     | 2    | King   |
  | F7       | Blue     | 1    | Normal |
  | F8       | Blue     | 1    | Normal |
  | I5       | Blue     | 1    | Cursed |
A5 OK
C7 OK
C2 OK
E7 OK
D1 OK
B4 OK
D7 OK
F5 OK
G4 OK
D8 OK
E9 OK
F7 OK
F8 OK
I5 OK
-> done: ValidationSteps.ThenTheFollowingLocationsMatch(<table>) (0.0s)
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/cbfbe4fe-269a-d5b9-20fa-1a0f44a4c1c8.png?raw=true)
]]></output>
                </test-case>
                <test-case id="0-1199" name="AlekSampleGame2" fullname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature.AlekSampleGame2" methodname="AlekSampleGame2" classname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature" runstate="Runnable" seed="1480417793" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.009169" asserts="290">
                  <properties>
                    <property name="Description" value="Alek Sample Game 2" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the following moves are performed:
  --- table step argument ---
  | RedAction1 | RedAction2 | BlueAction1 | BlueAction2 |
  | f1+f2      | @f1        | f8+f7       | @f8         |
  | d2+e3      | @d2        | d7+e7       | @d7         |
  | d1+d2      | @d1        | d8+d7       | @d8         |
  | e1+d1      | @e1        | e9+d8       | @e9         |
  | e1+f1      | @e1        | f8+e9       | @f8         |
  | e1+e2      | @e1        | f8+e8       | @f8         |
  | d1d3       | @d1        | d7b5        | @d7         |
  | f2h2       | @f2        | f7f5        | @f7         |
  | h2f4       | f4-1-f5    | e7e6        | e6-1-f5     |
  | Be7        | f4f5       | e6f5        | b5d5        |
  | d3d5       | d2d4       | d8-1-d7     | d7d5        |
  | d4d5       | f1f3       | f8+f7       | e8f8        |
  | d5f6       | f6-1-f7    | f5f6        | f8f7        |
  | f3f4       | e3e5       | f7e8        | @f7         |
  | e5d5       | f4f6       | f7f6        | e8f8        |
  | d5f6       | e2e4       | f8f6        | Be5         |
  | e4d3       | @e3        | f6h4        | Bh2         |
  | f2+e3      | e3g3       |             |             |
Accepted: f1+f2
Accepted: @f1
Accepted: f8+f7
Accepted: @f8
Accepted: d2+e3
Accepted: @d2
Accepted: d7+e7
Accepted: @d7
Accepted: d1+d2
Accepted: @d1
Accepted: d8+d7
Accepted: @d8
Accepted: e1+d1
Accepted: @e1
Accepted: e9+d8
Accepted: @e9
Accepted: e1+f1
Accepted: @e1
Accepted: f8+e9
Accepted: @f8
Accepted: e1+e2
Accepted: @e1
Accepted: f8+e8
Accepted: @f8
Accepted: d1d3
Accepted: @d1
Accepted: d7b5
Accepted: @d7
Accepted: f2h2
Accepted: @f2
Accepted: f7f5
Accepted: @f7
Accepted: h2f4
Accepted: f4-1-f5
Accepted: e7e6
Accepted: e6-1-f5
Accepted: Be7
Accepted: f4f5
Accepted: e6f5
Accepted: b5d5
Accepted: d3d5
Accepted: d2d4
Accepted: d8-1-d7
Accepted: d7d5
Accepted: d4d5
Accepted: f1f3
Accepted: f8+f7
Accepted: e8f8
Accepted: d5f6
Accepted: f6-1-f7
Accepted: f5f6
Accepted: f8f7
Accepted: f3f4
Accepted: e3e5
Accepted: f7e8
Accepted: @f7
Accepted: e5d5
Accepted: f4f6
Accepted: f7f6
Accepted: e8f8
Accepted: d5f6
Accepted: e2e4
Accepted: f8f6
Accepted: Be5
Accepted: e4d3
Accepted: @e3
Accepted: f6h4
Accepted: Bh2
Accepted: f2+e3
Accepted: e3g3
-> done: ActionSteps.WhenTheFollowingMoves(<table>) (0.0s)
Then the following locations match:
  --- table step argument ---
  | Location | Contents | Size | Type   |
  | E5       | Block    |      |        |
  | E7       | Block    |      |        |
  | H2       | Block    |      |        |
  | D1       | Red      | 1    | Normal |
  | D3       | Red      | 2    | King   |
  | E1       | Red      | 1    | Normal |
  | G3       | Red      | 2    | Normal |
  | D8       | Blue     | 1    | Normal |
  | H4       | Blue     | 2    | King   |
E5 OK
E7 OK
H2 OK
D1 OK
D3 OK
E1 OK
G3 OK
D8 OK
H4 OK
-> done: ValidationSteps.ThenTheFollowingLocationsMatch(<table>) (0.0s)
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/18d1edce-a867-a82c-a5b7-fc11081a6f77.png?raw=true)
]]></output>
                </test-case>
              </test-suite>
            </test-suite>
            <test-suite type="TestSuite" id="0-1204" name="GameRules" fullname="Testing.Specflow.Features.GameRules" runstate="Runnable" testcasecount="183" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.550794" total="183" passed="183" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="1387">
              <test-suite type="TestFixture" id="0-1001" name="BlockRulesFeature" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" testcasecount="7" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.017674" total="7" passed="7" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="105">
                <properties>
                  <property name="Description" value="Block Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1002" name="BlockHappyPath" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.BlockHappyPath" methodname="BlockHappyPath" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="1836747516" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.005031" asserts="5">
                  <properties>
                    <property name="Description" value="Block Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player blockades A1
Accepted: Ba1
-> done: ActionSteps.WhenIBlockade(Red, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has blocks matching: A1
Successfully validated 1 block.
-> done: ValidationSteps.ThenTheBoardHasBlocksMatching("A1") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1003" name="BlockMaximum" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.BlockMaximum" methodname="BlockMaximum" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="1129078785" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.004598" asserts="65">
                  <properties>
                    <property name="Description" value="Block Maximum" />
                    <property name="Category" value="scenario-image-only" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When the following moves are performed:
  --- table step argument ---
  | RedAction1 | RedAction2 | BlueAction1 | BlueAction2 |
  | Be9        | Bb6        | Bd7         | Bf7         |
  | Bh6        | Ba4        | Bc5         | Be6         |
  | Bg5        | Bi4        | Bb3         | Bd4         |
  | Bf4        | Bh3        | Ba1         | Bc2         |
  | Be3        | Bg2        | Bi1         | Bd1         |
  | Bf1        |            |             |             |
Accepted: Be9
Accepted: Bb6
Accepted: Bd7
Accepted: Bf7
Accepted: Bh6
Accepted: Ba4
Accepted: Bc5
Accepted: Be6
Accepted: Bg5
Accepted: Bi4
Accepted: Bb3
Accepted: Bd4
Accepted: Bf4
Accepted: Bh3
Accepted: Ba1
Accepted: Bc2
Accepted: Be3
Accepted: Bg2
Accepted: Bi1
Accepted: Bd1
Accepted: Bf1
-> done: ActionSteps.WhenTheFollowingMoves(<table>) (0.0s)
Then the board has blocks matching: A14B36C25D147E369F147G25H36I14
Successfully validated 21 blocks.
-> done: ValidationSteps.ThenTheBoardHasBlocksMatching("A14B36C25D147E369...") (0.0s)
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/bc5dab43-1e58-4c80-a904-8567f18be91f.png?raw=true)
]]></output>
                </test-case>
                <test-case id="0-1005" name="CannotBlockAdjacentAnotherBlock" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.CannotBlockAdjacentAnotherBlock" methodname="CannotBlockAdjacentAnotherBlock" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="1339445895" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002523" asserts="7">
                  <properties>
                    <property name="Description" value="Cannot Block Adjacent Another Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When the red player blocks e3
Accepted: Be3
-> done: ActionSteps.WhenIBlockade(Red, E3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player blocks e4
Rejected: Be4: Cannot Block Adjacent Existing Block E3
-> done: ActionSteps.WhenIBlockade(Red, E4) (0.0s)
Then the action fails
Failed with: Cannot Block Adjacent Existing Block E3
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And the board has blocks matching: E3
Successfully validated 1 block.
-> done: ValidationSteps.ThenTheBoardHasBlocksMatching("E3") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1004" name="CannotBlockHomeSpace" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.CannotBlockHomeSpace" methodname="CannotBlockHomeSpace" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="1822710666" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001395" asserts="8">
                  <properties>
                    <property name="Description" value="Cannot Block Home Space" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When the red player blocks e2
Rejected: Be2: Cannot Block Red Home at Location E2
-> done: ActionSteps.WhenIBlockade(Red, E2) (0.0s)
Then the action fails
Failed with: Cannot Block Red Home at Location E2
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player blocks e8
Rejected: Be8: Cannot Block Blue Home at Location E8
-> done: ActionSteps.WhenIBlockade(Red, E8) (0.0s)
Then the action fails
Failed with: Cannot Block Blue Home at Location E8
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1006" name="CannotBlockOccupiedSpace" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.CannotBlockOccupiedSpace" methodname="CannotBlockOccupiedSpace" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="995354967" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001331" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Block Occupied Space" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player blockades e3
Rejected: Be3: Location E3 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E3) (0.0s)
Then the action fails
Failed with: Location E3 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-suite type="ParameterizedMethod" id="0-1009" name="Wrap_AroundBlock" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.Wrap_AroundBlock" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" testcasecount="2" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002057" total="2" passed="2" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="14">
                  <properties>
                    <property name="Description" value="Wrap-Around Block" />
                  </properties>
                  <test-case id="0-1007" name="Wrap_AroundBlock(&quot;H6&quot;,&quot;A2&quot;,null)" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.Wrap_AroundBlock(&quot;H6&quot;,&quot;A2&quot;,null)" methodname="Wrap_AroundBlock" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="599808290" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001280" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When the red player blocks H6
Accepted: Bh6
-> done: ActionSteps.WhenIBlockade(Red, H6) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player blocks A2
Rejected: Ba2: Cannot Block Adjacent Existing Block H6
-> done: ActionSteps.WhenIBlockade(Red, A2) (0.0s)
Then the action fails
Failed with: Cannot Block Adjacent Existing Block H6
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And the board has blocks matching: H6
Successfully validated 1 block.
-> done: ValidationSteps.ThenTheBoardHasBlocksMatching("H6") (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1008" name="Wrap_AroundBlock(&quot;A2&quot;,&quot;H6&quot;,null)" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.Wrap_AroundBlock(&quot;A2&quot;,&quot;H6&quot;,null)" methodname="Wrap_AroundBlock" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="601008111" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000561" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When the red player blocks A2
Accepted: Ba2
-> done: ActionSteps.WhenIBlockade(Red, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player blocks H6
Rejected: Bh6: Cannot Block Adjacent Existing Block A2
-> done: ActionSteps.WhenIBlockade(Red, H6) (0.0s)
Then the action fails
Failed with: Cannot Block Adjacent Existing Block A2
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And the board has blocks matching: A2
Successfully validated 1 block.
-> done: ValidationSteps.ThenTheBoardHasBlocksMatching("A2") (0.0s)
]]></output>
                  </test-case>
                </test-suite>
              </test-suite>
              <test-suite type="TestFixture" id="0-1010" name="BridgeRulesFeature" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" testcasecount="7" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.030203" total="7" passed="7" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="25">
                <properties>
                  <property name="Description" value="Bridge Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1016" name="BridgeCannotBlessCursedPieces" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.BridgeCannotBlessCursedPieces" methodname="BridgeCannotBlessCursedPieces" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="758319945" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.004681" asserts="3">
                  <properties>
                    <property name="Description" value="Bridge Cannot Bless Cursed Pieces" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                         |
  | Benediction v1: R-E2 B E8     |
  | R:D12E12k3F6++G1c+2cH2c3c5c6c |
  | B:E8k                         |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/158a65d4-0647-72cd-9742-bd0974db56c7.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from f6 to h4
Accepted: f6-2-h4
-> done: ActionSteps.WhenISplit(Red, "2", F6, H4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3F6cG1c+2cH2c3c4b+5c6c
Successfully validated 13 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F6cG1c+2c...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1011" name="BridgeHappyPath" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.BridgeHappyPath" methodname="BridgeHappyPath" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="1566837227" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001947" asserts="2">
                  <properties>
                    <property name="Description" value="Bridge Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:C2D13E12k4F124G4H4I45   |
  | B:A12B3C4D578E68k9F68G6   |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/c9492abe-3358-0d32-63b9-0aa9dc29c560.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at d1 to c1
Accepted: d1c1
-> done: ActionSteps.WhenIMove(Red, D1, C1) (0.0s)
Then the board has red pieces matching: C1b2bD3bE12k4bF124bG4bH4bI4b5b
Successfully validated 13 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "C1b2bD3bE12k4bF12...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1012" name="BridgeMaximum" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.BridgeMaximum" methodname="BridgeMaximum" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="2117869431" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.008393" asserts="5">
                  <properties>
                    <property name="Description" value="Bridge Maximum" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                                   |
  | Benediction v1: R-E2 B E8               |
  | R:A14B245C246D468E2k468kF2467G246H24I23 |
  | B:E7k                                   |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/13d4a81a-dba4-1eed-9ef3-7b2bfec8217c.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player drops a new piece at d2
Accepted: @d2
-> done: ActionSteps.WhenIDrop(Red, D2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
And the board has red pieces matching: A1b4bB2b4b5bC2b4b6bD2b4b6b8bE2kb4b6b8kbF2b4b6b7bG2b4b6bH2b4bI2b3b
Successfully validated 27 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1b4bB2b4b5bC2b4b...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1013" name="BridgeWithWrongColorCriticalPiece" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.BridgeWithWrongColorCriticalPiece" methodname="BridgeWithWrongColorCriticalPiece" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="494788330" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.005807" asserts="4">
                  <properties>
                    <property name="Description" value="Bridge With Wrong Color Critical Piece" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:D12E12k3F12G2H2356      |
  | B:E8kG4                   |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/158a65d4-0647-72cd-d273-340ac98e5453.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at g4 to h4
Accepted: g4h4
-> done: ActionSteps.WhenIMove(Blue, G4, H4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has blue pieces matching: E8kH4
Successfully validated 2 Blue pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Blue, "E8kH4") (0.0s)
And the board has red pieces matching: D12E12k3F12G2H2356
Successfully validated 12 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F12G2H2356") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1017" name="HomeDropCompletingBridgeWinsGame" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.HomeDropCompletingBridgeWinsGame" methodname="HomeDropCompletingBridgeWinsGame" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="385367752" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002261" asserts="5">
                  <properties>
                    <property name="Description" value="Home Drop Completing Bridge Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1kE1345F5G5H5I5        |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/24b180f6-670c-6fab-3977-843ea82dc40d.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player drops a new piece at e2
Accepted: @e2
-> done: ActionSteps.WhenIDrop(Red, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: A1kE1b2kb3b4b5bF5bG5bH5bI5b
Successfully validated 10 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1kE1b2kb3b4b5bF5...") (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1014" name="SplitIntoBridgeAvoidsAllCursesIfSplitPiecesAdjacent" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.SplitIntoBridgeAvoidsAllCursesIfSplitPiecesAdjacent" methodname="SplitIntoBridgeAvoidsAllCursesIfSplitPiecesAdjacent" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="1879734973" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001767" asserts="3">
                  <properties>
                    <property name="Description" value="Split Into Bridge Avoids All Curses If Split Pieces Adjacent" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G25+H2356    |
  | B:E8k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/158a65d4-0647-72cd-5aeb-3fdc78ac6537.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from g5 to h4
Accepted: g5-1-h4
-> done: ActionSteps.WhenISplit(Red, "1", G5, H4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D1b2bE1b2kb3bF1b2bG2b5bH2b3b4b5b6b
Successfully validated 14 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D1b2bE1b2kb3bF1b2...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1015" name="SplitIntoBridgeAvoidsTargetCurseIfTargetPieceAdjacent" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.SplitIntoBridgeAvoidsTargetCurseIfTargetPieceAdjacent" methodname="SplitIntoBridgeAvoidsTargetCurseIfTargetPieceAdjacent" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="1637591922" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.004795" asserts="3">
                  <properties>
                    <property name="Description" value="Split Into Bridge Avoids Target Curse If Target Piece Adjacent" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F126++G2H2356   |
  | B:E8k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/158a65d4-0647-72cd-81dc-9bfa73b5405c.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from f6 to h4
Accepted: f6-2-h4
-> done: ActionSteps.WhenISplit(Red, "2", F6, H4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D1b2bE1b2kb3bF1b2b6cG2bH2b3b4b+5b6b
Successfully validated 14 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D1b2bE1b2kb3bF1b2...") (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1018" name="DropRulesFeature" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" testcasecount="5" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.007935" total="5" passed="5" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="25">
                <properties>
                  <property name="Description" value="Drop Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1021" name="CannotDropOntoBlock" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.CannotDropOntoBlock" methodname="CannotDropOntoBlock" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="1993188036" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002075" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Drop Onto Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12kF12              |
  | B:D78E78k9F78             |
  | X:E3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b69b9a3b-1ea6-087e-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player drops a new piece at e3
Rejected: @e3: Location E3 Not Empty
-> done: ActionSteps.WhenIDrop(Red, E3) (0.0s)
Then the action fails
Failed with: Location E3 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1022" name="CannotDropOntoOccupiedSpace" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.CannotDropOntoOccupiedSpace" methodname="CannotDropOntoOccupiedSpace" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="390306834" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001090" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Drop Onto Occupied Space" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player drops a new piece at e3
Rejected: @e3: Location E3 Not Empty
-> done: ActionSteps.WhenIDrop(Red, E3) (0.0s)
Then the action fails
Failed with: Location E3 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1020" name="CannotDropOutsideZone" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.CannotDropOutsideZone" methodname="CannotDropOutsideZone" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="1352412065" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001032" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Drop Outside Zone" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player drops a new piece at e5
Rejected: @e5: Drop Must Be Adjacent Your Home At E2
-> done: ActionSteps.WhenIDrop(Red, E5) (0.0s)
Then the action fails
Failed with: Drop Must Be Adjacent Your Home At E2
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1019" name="DropHappyPath" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.DropHappyPath" methodname="DropHappyPath" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="657588791" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001791" asserts="6">
                  <properties>
                    <property name="Description" value="Drop Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player drops a new piece at e3
Accepted: @e3
-> done: ActionSteps.WhenIDrop(Red, E3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1023" name="HomeDropBecomesKing" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.HomeDropBecomesKing" methodname="HomeDropBecomesKing" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="1829505835" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001315" asserts="3">
                  <properties>
                    <property name="Description" value="Home Drop Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E13kF12              |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/e318acc5-7959-e317-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player drops a new piece at e2
Accepted: @e2
-> done: ActionSteps.WhenIDrop(Red, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3kF12
Successfully validated 7 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3kF12") (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1024" name="ExamplesFeature" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" testcasecount="22" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.025383" total="22" passed="22" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="238">
                <properties>
                  <property name="Description" value="Examples" />
                  <property name="Category" value="no-images" />
                </properties>
                <test-case id="0-1031" name="CannotBlockOwnKing" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.CannotBlockOwnKing" methodname="CannotBlockOwnKing" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1182799334" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002884" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Block Own King" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When red does Be2
Rejected: Be2: Cannot Block Red Home at Location E2
-> done: ActionSteps.WhenDoes(Red, "Be2") (0.0s)
Then the action fails
Failed with: Cannot Block Red Home at Location E2
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1025" name="LoadAPreviouslyCreatedBoard" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.LoadAPreviouslyCreatedBoard" methodname="LoadAPreviouslyCreatedBoard" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="907559214" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000864" asserts="2">
                  <properties>
                    <property name="Description" value="Load a Previously Created Board" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I have board WeirdSituation1
Loaded board WeirdSituation1.
-> done: SetupSteps.GivenIHaveNamedBoard("WeirdSituation1") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1027" name="LoadASavedBoard" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.LoadASavedBoard" methodname="LoadASavedBoard" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="347417300" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000965" asserts="0">
                  <properties>
                    <property name="Description" value="Load a Saved Board" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                       |
  | Benediction v1: R E2 B-E8   |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+ |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+ |
  | X:B5C2D4E6F3H6I1            |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1032" name="MergeSplitMergeDoesntCreatePieces" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.MergeSplitMergeDoesntCreatePieces" methodname="MergeSplitMergeDoesntCreatePieces" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="3153281" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001497" asserts="3">
                  <properties>
                    <property name="Description" value="Merge Split Merge Doesn't Create Pieces" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 onto e3
Accepted: f2+e3
-> done: ActionSteps.WhenIMerge(Red, F2, E3) (0.0s)
And the red player splits 1 piece from e3 onto d2
Accepted: e3-1-d2
-> done: ActionSteps.WhenISplit(Red, "1", E3, D2) (0.0s)
Then the board has red pieces matching: D12+E12k3F1
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12+E12k3F1") (0.0s)
]]></output>
                </test-case>
                <test-suite type="ParameterizedMethod" id="0-1047" name="NoneOfTheseAreValidBlockLocations" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" testcasecount="14" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.006947" total="14" passed="14" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="56">
                  <properties>
                    <property name="Description" value="None of These Are Valid Block Locations" />
                  </properties>
                  <test-case id="0-1033" name="NoneOfTheseAreValidBlockLocations(&quot;d1&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;d1&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1008226710" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001234" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades d1
Rejected: Bd1: Location D1 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, D1) (0.0s)
Then the action fails
Failed with: Location D1 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1034" name="NoneOfTheseAreValidBlockLocations(&quot;d2&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;d2&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1403502597" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000406" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades d2
Rejected: Bd2: Location D2 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, D2) (0.0s)
Then the action fails
Failed with: Location D2 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1035" name="NoneOfTheseAreValidBlockLocations(&quot;e1&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e1&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="557104287" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000374" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e1
Rejected: Be1: Location E1 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E1) (0.0s)
Then the action fails
Failed with: Location E1 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1036" name="NoneOfTheseAreValidBlockLocations(&quot;e2&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e2&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="547482939" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000342" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e2
Rejected: Be2: Location E2 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E2) (0.0s)
Then the action fails
Failed with: Location E2 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1037" name="NoneOfTheseAreValidBlockLocations(&quot;e3&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e3&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="272075056" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000348" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e3
Rejected: Be3: Location E3 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E3) (0.0s)
Then the action fails
Failed with: Location E3 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1038" name="NoneOfTheseAreValidBlockLocations(&quot;f1&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;f1&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1837581527" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000380" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades f1
Rejected: Bf1: Location F1 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, F1) (0.0s)
Then the action fails
Failed with: Location F1 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1039" name="NoneOfTheseAreValidBlockLocations(&quot;f2&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;f2&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1239829775" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000341" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades f2
Rejected: Bf2: Location F2 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, F2) (0.0s)
Then the action fails
Failed with: Location F2 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1040" name="NoneOfTheseAreValidBlockLocations(&quot;d7&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;d7&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="463489766" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000332" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades d7
Rejected: Bd7: Location D7 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, D7) (0.0s)
Then the action fails
Failed with: Location D7 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1041" name="NoneOfTheseAreValidBlockLocations(&quot;d8&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;d8&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1470421345" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000350" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades d8
Rejected: Bd8: Location D8 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, D8) (0.0s)
Then the action fails
Failed with: Location D8 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1042" name="NoneOfTheseAreValidBlockLocations(&quot;e7&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e7&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1994649020" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000331" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e7
Rejected: Be7: Location E7 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E7) (0.0s)
Then the action fails
Failed with: Location E7 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1043" name="NoneOfTheseAreValidBlockLocations(&quot;e8&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e8&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="106103643" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001273" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e8
Rejected: Be8: Location E8 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E8) (0.0s)
Then the action fails
Failed with: Location E8 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1044" name="NoneOfTheseAreValidBlockLocations(&quot;e9&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e9&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="2143246540" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000416" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e9
Rejected: Be9: Location E9 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E9) (0.0s)
Then the action fails
Failed with: Location E9 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1045" name="NoneOfTheseAreValidBlockLocations(&quot;f7&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;f7&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="279349228" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000348" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades f7
Rejected: Bf7: Location F7 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, F7) (0.0s)
Then the action fails
Failed with: Location F7 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1046" name="NoneOfTheseAreValidBlockLocations(&quot;f8&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;f8&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="935055072" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000334" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades f8
Rejected: Bf8: Location F8 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, F8) (0.0s)
Then the action fails
Failed with: Location F8 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                </test-suite>
                <test-case id="0-1028" name="PerformSomeMoves" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.PerformSomeMoves" methodname="PerformSomeMoves" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="749074071" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001700" asserts="6">
                  <properties>
                    <property name="Description" value="Perform Some Moves" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at e3 to e4
Accepted: e3e4
-> done: ActionSteps.WhenIMove(Red, E3, E4) (0.0s)
When the red player drops a new piece at e3
Accepted: @e3
-> done: ActionSteps.WhenIDrop(Red, E3) (0.0s)
When the blue player blockades c2
Accepted: Bc2
-> done: ActionSteps.WhenIBlockade(Blue, C2) (0.0s)
When the blue player merges the piece at f7 into e7
Accepted: f7+e7
-> done: ActionSteps.WhenIMerge(Blue, F7, E7) (0.0s)
When the red player merges the piece at e4 into e3
Accepted: e4+e3
-> done: ActionSteps.WhenIMerge(Red, E4, E3) (0.0s)
When the red player splits 1 piece from e3 onto d2
Accepted: e3-1-d2
-> done: ActionSteps.WhenISplit(Red, "1", E3, D2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1029" name="PerformSomeMoves_ShortNotation" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.PerformSomeMoves_ShortNotation" methodname="PerformSomeMoves_ShortNotation" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="709758717" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001974" asserts="22">
                  <properties>
                    <property name="Description" value="Perform Some Moves - Short Notation" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When red does e3e4
Accepted: e3e4
-> done: ActionSteps.WhenDoes(Red, "e3e4") (0.0s)
When red does @e3
Accepted: @e3
-> done: ActionSteps.WhenDoes(Red, "@e3") (0.0s)
When blue does Bc2
Accepted: Bc2
-> done: ActionSteps.WhenDoes(Blue, "Bc2") (0.0s)
When blue does f7+e7
Accepted: f7+e7
-> done: ActionSteps.WhenDoes(Blue, "f7+e7") (0.0s)
When red does e4+e3
Accepted: e4+e3
-> done: ActionSteps.WhenDoes(Red, "e4+e3") (0.0s)
When red does e3-1-d2
Accepted: e3-1-d2
-> done: ActionSteps.WhenDoes(Red, "e3-1-d2") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1030" name="PerformSomeMoves_TableNotation" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.PerformSomeMoves_TableNotation" methodname="PerformSomeMoves_TableNotation" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="423776978" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.005664" asserts="141">
                  <properties>
                    <property name="Description" value="Perform Some Moves - Table Notation" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the following moves are performed:
  --- table step argument ---
  | RedAction1 | RedAction2 | BlueAction1 | BlueAction2 |
  | f1+f2      | f2-1-g2    | e8+e9       | Bi3         |
  | e3+d2      | Bb5        | f7+f8       | f8f7        |
  | d2c1       | e1f1       | Ba2         | f7-1-g7     |
  | e2e3       | d1e1       | Bf8         | f7g6        |
  | Bg1        | Bb1        | Bd4         | d7+e7       |
  | f1+e1      | f2e2       | @d7         | d7+d8       |
  | @f2        | f2+e2      | @d7         | @e8         |
  | @f2        | e3+f2      | e8+d7       | @e8         |
  | @d1        | @e3        | @f7         | f7+e8       |
  | @f1        | @d2        | @f7         | Bd6         |
Accepted: f1+f2
Accepted: f2-1-g2
Accepted: e8+e9
Accepted: Bi3
Accepted: e3+d2
Accepted: Bb5
Accepted: f7+f8
Accepted: f8f7
Accepted: d2c1
Accepted: e1f1
Accepted: Ba2
Accepted: f7-1-g7
Accepted: e2e3
Accepted: d1e1
Accepted: Bf8
Accepted: f7g6
Accepted: Bg1
Accepted: Bb1
Accepted: Bd4
Accepted: d7+e7
Accepted: f1+e1
Accepted: f2e2
Accepted: @d7
Accepted: d7+d8
Accepted: @f2
Accepted: f2+e2
Accepted: @d7
Accepted: @e8
Accepted: @f2
Accepted: e3+f2
Accepted: e8+d7
Accepted: @e8
Accepted: @d1
Accepted: @e3
Accepted: @f7
Accepted: f7+e8
Accepted: @f1
Accepted: @d2
Accepted: @f7
Accepted: Bd6
-> done: ActionSteps.WhenTheFollowingMoves(<table>) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1026" name="StartFromAnEmptyBoard" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.StartFromAnEmptyBoard" methodname="StartFromAnEmptyBoard" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1600781973" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002063" asserts="2">
                  <properties>
                    <property name="Description" value="Start From an Empty Board" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
And I add this red piece: E3k+
-> done: SetupSteps.GivenIAddPieces(Red, "E3k+") (0.0s)
And I add these blue pieces: D45+E56k7F5++++6+b+++7+++++
-> done: SetupSteps.GivenIAddPieces(Blue, "D45+E56k7F5++++6+...") (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1048" name="MergeRulesFeature" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" testcasecount="14" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.023068" total="14" passed="14" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="82">
                <properties>
                  <property name="Description" value="Merge Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1062" name="CannotMergeAboveStackSizeFifteen" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeAboveStackSizeFifteen" methodname="CannotMergeAboveStackSizeFifteen" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="695825977" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002464" asserts="20">
                  <properties>
                    <property name="Description" value="Cannot Merge Above Stack Size Fifteen" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                                                       |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/f63607a3-2d9b-16ec-f2e3-88e1c92baf0d.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e3
Rejected: f2+e3: Merging Stacks Size 8 and 8 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, F2, E3) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 8 and 8 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece at d2 into e2
Rejected: d2+e2: Merging Stacks Size 15 and 1 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, D2, E2) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 15 and 1 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece at d2 into e3
Rejected: d2+e3: Merging Stacks Size 15 and 8 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, D2, E3) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 15 and 8 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece at d2 into d1
Rejected: d2+d1: Merging Stacks Size 15 and 14 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, D2, D1) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 15 and 14 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece at d1 into e1
Rejected: d1+e1: Merging Stacks Size 14 and 2 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, D1, E1) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 14 and 2 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1056" name="CannotMergeCursedAndCursed" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeCursedAndCursed" methodname="CannotMergeCursedAndCursed" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="2102166237" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001075" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Merge Cursed and Cursed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F1c2c           |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c1f4-5b3f6f2c3f6f.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into f1
Rejected: f2+f1: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1060" name="CannotMergeCursedAndKing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeCursedAndKing" methodname="CannotMergeCursedAndKing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1708697503" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001081" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Merge Cursed and King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12c            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c1e3-8e3bfa808e36.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Rejected: f2+e2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1055" name="CannotMergeCursedAndNormal" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeCursedAndNormal" methodname="CannotMergeCursedAndNormal" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="663923241" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001786" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Merge Cursed and Normal" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F1c2            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c12d-6b26e7edd63a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into f1
Rejected: f2+f1: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1061" name="CannotMergeKingAndKing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeKingAndKing" methodname="CannotMergeKingAndKing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="178945310" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001085" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Merge King and King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12k            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c1aa-7f5482bff66a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Rejected: f2+e2: Kings Cannot Merge With Kings
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action fails
Failed with: Kings Cannot Merge With Kings
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1052" name="MergeAboveSizeTwoRequiresBlessing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeAboveSizeTwoRequiresBlessing" methodname="MergeAboveSizeTwoRequiresBlessing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="2060559739" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001432" asserts="12">
                  <properties>
                    <property name="Description" value="Merge Above Size Two Requires Blessing" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player merges the piece at f2 into f1
Rejected: f2+f1: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
Given I add these red pieces: F2+b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/ed861c2b-6429-c948-afea-9d5bfd641f95.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "F2+b") (0.0s)
When the red player merges the piece at f2 into f1
Accepted: f2+f1
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12kF1++
Successfully validated 5 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12kF1++") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1059" name="MergeBlessedAndKing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeBlessedAndKing" methodname="MergeBlessedAndKing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1040934872" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.004098" asserts="4">
                  <properties>
                    <property name="Description" value="Merge Blessed and King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12b+           |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-483f-f3b052ba746a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Accepted: f2+e2
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king on e2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "three", E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1054" name="MergeCursedAndBlessed" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeCursedAndBlessed" methodname="MergeCursedAndBlessed" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1506590643" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001384" asserts="3">
                  <properties>
                    <property name="Description" value="Merge Cursed and Blessed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F1c2b           |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-815f-a72c89fdf007.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into f1
Accepted: f2+f1
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3F1+
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F1+") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1049" name="MergeHappyPath" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeHappyPath" methodname="MergeHappyPath" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="73625561" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000999" asserts="4">
                  <properties>
                    <property name="Description" value="Merge Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1050" name="MergeMaximum" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeMaximum" methodname="MergeMaximum" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="819221762" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001400" asserts="3">
                  <properties>
                    <property name="Description" value="Merge Maximum" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                       |
  | Benediction v1: R-E2 B E8   |
  | R:D12E12k3++++++F12b+++++++ |
  | B:D78E78k9F78               |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/17aa7f72-5aba-a35b-f2e3-88e1c92baf0d.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 onto e3
Accepted: f2+e3
-> done: ActionSteps.WhenIMerge(Red, F2, E3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3++++++++++++++F1
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3+++++++++...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1053" name="MergeNormalAndBlessed" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeNormalAndBlessed" methodname="MergeNormalAndBlessed" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="541120734" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001335" asserts="3">
                  <properties>
                    <property name="Description" value="Merge Normal and Blessed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12b            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-814e-da28145240cf.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into f1
Accepted: f2+f1
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3F1+
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F1+") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1057" name="MergeNormalAndKing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeNormalAndKing" methodname="MergeNormalAndKing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="786416275" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001415" asserts="4">
                  <properties>
                    <property name="Description" value="Merge Normal and King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Accepted: f2+e2
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king on e2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1058" name="MergeNormalAndKingAboveStackSizeTwoRequiresBlessing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeNormalAndKingAboveStackSizeTwoRequiresBlessing" methodname="MergeNormalAndKingAboveStackSizeTwoRequiresBlessing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="342733137" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001704" asserts="9">
                  <properties>
                    <property name="Description" value="Merge Normal and King Above Stack Size Two Requires Blessing" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12+            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-880d-b7aab0aa5a9d.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Rejected: f2+e2: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
Given I add this red piece: F2b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-483f-f3b052ba746a.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "F2b+") (0.0s)
When the red player merges the piece at f2 into e2
Accepted: f2+e2
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king on e2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "three", E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1051" name="MergeNormalAndNormal" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeNormalAndNormal" methodname="MergeNormalAndNormal" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1175399417" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001199" asserts="4">
                  <properties>
                    <property name="Description" value="Merge Normal and Normal" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1063" name="MovementRulesFeature" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" testcasecount="9" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.023840" total="9" passed="9" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="97">
                <properties>
                  <property name="Description" value="Movement Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1066" name="BlueCannotMoveThroughBlueWall" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.BlueCannotMoveThroughBlueWall" methodname="BlueCannotMoveThroughBlueWall" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="332354131" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.008583" asserts="31">
                  <properties>
                    <property name="Description" value="Blue Cannot Move Through Blue Wall" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
And the current turn is BlueAction1
Board flags set to: BlueAction1
-> done: CommonSteps.GivenTheCurrentTurnIsRed(BlueAction1) (0.0s)
When the blue player moves the piece at e9 to e1
Rejected: e9e1: Stack Size 1 Piece At E9 Cannot Reach E1 (but can reach: E8)
-> done: ActionSteps.WhenIMove(Blue, E9, E1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E9 Cannot Reach E1 (but can reach: E8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at e9 to e5
Rejected: e9e5: Stack Size 1 Piece At E9 Cannot Reach E5 (but can reach: E8)
-> done: ActionSteps.WhenIMove(Blue, E9, E5) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E9 Cannot Reach E5 (but can reach: E8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at e9 to a5
Rejected: e9a5: Stack Size 1 Piece At E9 Cannot Reach A5 (but can reach: D8)
-> done: ActionSteps.WhenIMove(Blue, E9, A5) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E9 Cannot Reach A5 (but can reach: D8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at f8 to f1
Rejected: f8f1: Stack Size 1 Piece At F8 Cannot Reach F1 (but can reach: F7)
-> done: ActionSteps.WhenIMove(Blue, F8, F1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F8 Cannot Reach F1 (but can reach: F7)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at f8 to a4
Rejected: f8a4: Stack Size 1 Piece At F8 Cannot Reach A4 (but can reach: E8)
-> done: ActionSteps.WhenIMove(Blue, F8, A4) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F8 Cannot Reach A4 (but can reach: E8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at d8 to d1
Rejected: d8d1: Stack Size 1 Piece At D8 Cannot Reach D1 (but can reach: D7)
-> done: ActionSteps.WhenIMove(Blue, D8, D1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D8 Cannot Reach D1 (but can reach: D7)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at d8 to i4
Rejected: d8i4: Stack Size 1 Piece At D8 Cannot Reach I4 (but can reach: E8)
-> done: ActionSteps.WhenIMove(Blue, D8, I4) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D8 Cannot Reach I4 (but can reach: E8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1068" name="CanCaptureEnemyPiece" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CanCaptureEnemyPiece" methodname="CanCaptureEnemyPiece" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="1678538517" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.003945" asserts="4">
                  <properties>
                    <property name="Description" value="Can Capture Enemy Piece" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F24+            |
  | B:D5+7E78k9F78            |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/93c1cff7-b53a-a730-defb-a4059a976ea0.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at f4 two points to the northwest
Accepted: f4d5
-> done: ActionSteps.WhenIMovePointsDirection(Red, F4, "two", "northwest") (0.0s)
Then there should be a red two-stack on d5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", D5) (0.0s)
And there should not be any blue pieces on d5
-> done: ValidationSteps.ThenThereShouldNotBeAny(Blue, D5) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1069" name="CannotCaptureOwnPiece" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CannotCaptureOwnPiece" methodname="CannotCaptureOwnPiece" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="1592401033" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001193" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Capture Own Piece" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F24+            |
  | B:D5+7E78k9F78            |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/93c1cff7-b53a-a730-defb-a4059a976ea0.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at f4 two points to the south
Rejected: f4f2: Destination F2 Is Your Own Piece and Cannot Be Moved Onto By Red
-> done: ActionSteps.WhenIMovePointsDirection(Red, F4, "two", "south") (0.0s)
Then the action fails
Failed with: Destination F2 Is Your Own Piece and Cannot Be Moved Onto By Red
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1067" name="CannotDepartEdgeOfBoard" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CannotDepartEdgeOfBoard" methodname="CannotDepartEdgeOfBoard" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="421988931" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001121" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Depart Edge Of Board" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3H2+             |
  | B:B5+E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/47ea0c02-2fcc-0170-6b6f-2c6a4206026e.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at h2 two points to the northeast
Unable to reach point 2 northeast from I2 (starting from H2)
-> done: ActionSteps.WhenIMovePointsDirection(Red, H2, "two", "northeast") (0.0s)
Then the action fails
Failed with: Unable to reach point 2 northeast from I2 (starting from H2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1070" name="CannotMoveOntoBlock" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CannotMoveOntoBlock" methodname="CannotMoveOntoBlock" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="244778179" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002403" asserts="9">
                  <properties>
                    <property name="Description" value="Cannot Move Onto Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F24+            |
  | B:D5+7E78k9F78            |
  | X:E5G3                    |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/ccae0707-98c8-3569-4e9b-b7a5c7c68c32.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at f4 to e5
Rejected: f4e5: Destination E5 Contains a Block, Which Cannot Be Moved Onto
-> done: ActionSteps.WhenIMove(Red, F4, E5) (0.0s)
Then the action fails
Failed with: Destination E5 Contains a Block, Which Cannot Be Moved Onto
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
Given the current turn is BlueAction1
Board flags set to: BlueAction1
-> done: CommonSteps.GivenTheCurrentTurnIsRed(BlueAction1) (0.0s)
When the blue player moves the piece at d5 to e5
Rejected: d5e5: Destination E5 Contains a Block, Which Cannot Be Moved Onto
-> done: ActionSteps.WhenIMove(Blue, D5, E5) (0.0s)
Then the action fails
Failed with: Destination E5 Contains a Block, Which Cannot Be Moved Onto
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1071" name="CannotMoveOverBlock" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CannotMoveOverBlock" methodname="CannotMoveOverBlock" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="431736766" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001388" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Move Over Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F24+            |
  | B:D5+7E78k9F78            |
  | X:E5G3                    |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/ccae0707-98c8-3569-4e9b-b7a5c7c68c32.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at f4 two points to the northwest
Rejected: f4d5: Stack Size 2 Piece At F4 Cannot Reach D5 (but can reach: )
-> done: ActionSteps.WhenIMovePointsDirection(Red, F4, "two", "northwest") (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At F4 Cannot Reach D5 (but can reach: )
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1072" name="MoveThroughWallIsAssumedIfPossible" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.MoveThroughWallIsAssumedIfPossible" methodname="MoveThroughWallIsAssumedIfPossible" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="392018777" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001804" asserts="3">
                  <properties>
                    <property name="Description" value="Move Through Wall Is Assumed If Possible" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B=E8 |
  | R:D12E12k3H4+++           |
  | B:B3+++D8E8k9F78          |
  | X:E5F6G3                  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/60c4bc17-557e-e154-37bc-2d97af9170c6.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at b3 to b5
Accepted: b3b5
-> done: ActionSteps.WhenIMove(Blue, B3, B5) (0.0s)
Then there should be a blue four-stack with a blessing on b5
-> done: ValidationSteps.ThenThereShouldBeBlessed(Blue, "four", B5) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1065" name="RedCannotMoveThroughRedWall" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.RedCannotMoveThroughRedWall" methodname="RedCannotMoveThroughRedWall" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="1022690856" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001667" asserts="30">
                  <properties>
                    <property name="Description" value="Red Cannot Move Through Red Wall" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player moves the piece at e1 to e9
Rejected: e1e9: Stack Size 1 Piece At E1 Cannot Reach E9 (but can reach: E2)
-> done: ActionSteps.WhenIMove(Red, E1, E9) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E1 Cannot Reach E9 (but can reach: E2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at e1 to i1
Rejected: e1i1: Stack Size 1 Piece At E1 Cannot Reach I1 (but can reach: F1)
-> done: ActionSteps.WhenIMove(Red, E1, I1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E1 Cannot Reach I1 (but can reach: F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at e1 to a1
Rejected: e1a1: Stack Size 1 Piece At E1 Cannot Reach A1 (but can reach: D1)
-> done: ActionSteps.WhenIMove(Red, E1, A1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E1 Cannot Reach A1 (but can reach: D1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at f1 to f8
Rejected: f1f8: Stack Size 1 Piece At F1 Cannot Reach F8 (but can reach: F2)
-> done: ActionSteps.WhenIMove(Red, F1, F8) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F1 Cannot Reach F8 (but can reach: F2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at f1 to a2
Rejected: f1a2: Stack Size 1 Piece At F1 Cannot Reach A2 (but can reach: E2)
-> done: ActionSteps.WhenIMove(Red, F1, A2) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F1 Cannot Reach A2 (but can reach: E2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at d1 to i2
Rejected: d1i2: Stack Size 1 Piece At D1 Cannot Reach I2 (but can reach: E2)
-> done: ActionSteps.WhenIMove(Red, D1, I2) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D1 Cannot Reach I2 (but can reach: E2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at d1 to d8
Rejected: d1d8: Stack Size 1 Piece At D1 Cannot Reach D8 (but can reach: D2)
-> done: ActionSteps.WhenIMove(Red, D1, D8) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D1 Cannot Reach D8 (but can reach: D2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1064" name="RepeatMovesNotAllowed" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.RepeatMovesNotAllowed" methodname="RepeatMovesNotAllowed" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="1493684827" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001150" asserts="8">
                  <properties>
                    <property name="Description" value="Repeat Moves Not Allowed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player moves the piece at e3 to e4
Accepted: e3e4
-> done: ActionSteps.WhenIMove(Red, E3, E4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player moves the piece at e4 to e5
Rejected: e4e5: Piece at E4 Has Already Moved This Turn
-> done: ActionSteps.WhenIMove(Red, E4, E5) (0.0s)
Then the action fails
Failed with: Piece at E4 Has Already Moved This Turn
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1073" name="SplitRulesFeature" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" testcasecount="82" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.077684" total="82" passed="82" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="622">
                <properties>
                  <property name="Description" value="Split Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1088" name="BlessedStackLosesBlessingUponSplit_Merge" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.BlessedStackLosesBlessingUponSplit_Merge" methodname="BlessedStackLosesBlessingUponSplit_Merge" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="481311951" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001920" asserts="6">
                  <properties>
                    <property name="Description" value="Blessed Stack Loses Blessing Upon Split-Merge" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3b+4F12          |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/bc148ca4-4182-68e3-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from e3 onto e4
Accepted: e3-1-e4
-> done: ActionSteps.WhenISplit(Red, "1", E3, E4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on e4
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", E4) (0.0s)
And there should be a red one-stack on e3
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E3) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1090" name="CannotSplit_MergeBlessedStackOntoKingOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeBlessedStackOntoKingOverStackSizeTwo" methodname="CannotSplit_MergeBlessedStackOntoKingOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1846720196" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001076" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Blessed Stack Onto King Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5kF12         |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/5853337f-b337-afff-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1089" name="CannotSplit_MergeBlessedStackOntoRegularPieceOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeBlessedStackOntoRegularPieceOverStackSizeTwo" methodname="CannotSplit_MergeBlessedStackOntoRegularPieceOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1237449466" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001048" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Blessed Stack Onto Regular Piece Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5F12          |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/3acc517f-4170-e8e3-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1084" name="CannotSplit_MergeOntoCursedPiece" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeOntoCursedPiece" methodname="CannotSplit_MergeOntoCursedPiece" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="42783978" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001229" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Onto Cursed Piece" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3cF12            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/dd9a512c-dc97-ff02-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f1 into f2
Accepted: f1+f2
-> done: ActionSteps.WhenIMerge(Red, F1, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player splits 1 piece from f2 onto e3
Rejected: f2-1-e3: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", F2, E3) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1087" name="CannotSplit_MergeOntoKingOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeOntoKingOverStackSizeTwo" methodname="CannotSplit_MergeOntoKingOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="2129082964" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001217" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Onto King Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5kF12         |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/5853337f-b337-afff-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1086" name="CannotSplit_MergeOntoRegularPieceOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeOntoRegularPieceOverStackSizeTwo" methodname="CannotSplit_MergeOntoRegularPieceOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="453891667" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001123" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Onto Regular Piece Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5F12          |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/3acc517f-4170-e8e3-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1085" name="CannotSplit_MergeOverBlock" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeOverBlock" methodname="CannotSplit_MergeOverBlock" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1152192445" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001120" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Over Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5bF12         |
  | B:D78E78k9F78             |
  | X:E4                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/feef052f-37f4-c2f6-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Stack Size 2 Piece At E3 Cannot Reach E5 (but can reach: E2, E1)
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At E3 Cannot Reach E5 (but can reach: E2, E1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1082" name="Split_CaptureCannotMoveOverBlock" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_CaptureCannotMoveOverBlock" methodname="Split_CaptureCannotMoveOverBlock" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="749407718" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001120" asserts="4">
                  <properties>
                    <property name="Description" value="Split-Capture Cannot Move Over Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12+++          |
  | B:D78E78k9F478            |
  | X:F3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-dd94-8d3740e965ef.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from f2 onto f4
Rejected: f2-2-f4: Stack Size 2 Piece At F2 Cannot Reach F4 (but can reach: F1)
-> done: ActionSteps.WhenISplit(Red, "2", F2, F4) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At F2 Cannot Reach F4 (but can reach: F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1075" name="Split_CaptureHappyPath" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_CaptureHappyPath" methodname="Split_CaptureHappyPath" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1522038559" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001237" asserts="3">
                  <properties>
                    <property name="Description" value="Split-Capture Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:D12E12k6+F1             |
  | B:D78E78k9F5+             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/ed861c2b-6429-c948-4d6f-164b928b9889.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from e6 onto e7
Accepted: e6-1-e7
-> done: ActionSteps.WhenISplit(Red, "1", E6, E7) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k6c7cF1
Successfully validated 7 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k6c7cF1") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1091" name="Split_MergeBlessedStackOntoBlessedPieceOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeBlessedStackOntoBlessedPieceOverStackSizeTwo" methodname="Split_MergeBlessedStackOntoBlessedPieceOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1089220130" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001239" asserts="6">
                  <properties>
                    <property name="Description" value="Split-Merge Blessed Stack Onto Blessed Piece Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5bF12         |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/1e7d2dbf-cfa9-21c6-c11c-9e2272422602.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Accepted: e3-2-e5
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on e5
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", E5) (0.0s)
And there should be a red one-stack on e3
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E3) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1076" name="Split_MergeHappyPath" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeHappyPath" methodname="Split_MergeHappyPath" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1781494173" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001227" asserts="6">
                  <properties>
                    <property name="Description" value="Split-Merge Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
And the red player splits 1 piece from f2 onto f1
Accepted: f2-1-f1
-> done: ActionSteps.WhenISplit(Red, "1", F2, F1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12kF1+2
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12kF1+2") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1083" name="Split_MergeLeavesCorrectlySizedStacks" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeLeavesCorrectlySizedStacks" methodname="Split_MergeLeavesCorrectlySizedStacks" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="474059960" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001511" asserts="14">
                  <properties>
                    <property name="Description" value="Split-Merge Leaves Correctly Sized Stacks" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board LargeStacks
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/f63607a3-2d9b-16ec-f2e3-88e1c92baf0d.png?raw=true)
Loaded board LargeStacks.
-> done: SetupSteps.GivenIHaveNamedBoard("LargeStacks") (0.0s)
When the red player splits 6 pieces from f2 onto e3
Accepted: f2-6-e3
-> done: ActionSteps.WhenISplit(Red, "6", F2, E3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red fourteen-stack on e3
-> done: ValidationSteps.ThenThereShouldBe(Red, "fourteen", E3) (0.0s)
And there should be a red two-stack on f2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", F2) (0.0s)
When the red player splits 1 piece from d2 onto d1
Accepted: d2-1-d1
-> done: ActionSteps.WhenISplit(Red, "1", D2, D1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red fourteen-stack on d2
-> done: ValidationSteps.ThenThereShouldBe(Red, "fourteen", D2) (0.0s)
And there should be a red fifteen-stack on d1
-> done: ValidationSteps.ThenThereShouldBe(Red, "fifteen", D1) (0.0s)
]]></output>
                </test-case>
                <test-suite type="ParameterizedMethod" id="0-1157" name="Split_MergeRuleTest_Adjacent" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" testcasecount="32" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.026721" total="32" passed="32" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="254">
                  <properties>
                    <property name="Description" value="Split-Merge Rule Test - Adjacent" />
                  </properties>
                  <test-case id="0-1125" name="Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1368791328" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001479" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1+A2
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/f0c83c8d-93e4-c8ea-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1+A2") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1126" name="Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1681835141" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001611" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1+A2b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/df96924d-a55a-e6c5-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1+A2b") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1127" name="Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;c&quot;,&quot;fails&quot;,&quot;two-stack&quot;,&quot;cursed one-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;c&quot;,&quot;fails&quot;,&quot;two-stack&quot;,&quot;cursed one-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="819005380" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001352" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1+A2c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/ac01938d-d9bc-4056-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1+A2c") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red cursed one-stack on a2
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "one", A2) (0.0s)
And there should be a red two-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1128" name="Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;k&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;k&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1638012444" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000745" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1+A2k
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/673aea8d-1f94-b7c3-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1+A2k") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1129" name="Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;+&quot;,&quot;fails&quot;,&quot;two-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;+&quot;,&quot;fails&quot;,&quot;two-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="340529770" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000697" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1+A2+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/c88375e4-002a-e562-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1+A2+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red two-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A2) (0.0s)
And there should be a red two-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1130" name="Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="439152986" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000718" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1+A2b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b751cba4-11a0-033d-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1+A2b+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1131" name="Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;c+&quot;,&quot;fails&quot;,&quot;two-stack&quot;,&quot;cursed two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;c+&quot;,&quot;fails&quot;,&quot;two-stack&quot;,&quot;cursed two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="275472005" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000668" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1+A2c+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/83bccce4-4602-5cce-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1+A2c+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red cursed two-stack on a2
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A2) (0.0s)
And there should be a red two-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1132" name="Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;two-stack&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;two-stack&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1458429249" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000661" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1+A2k+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/3ef623e4-8bda-d43a-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1+A2k+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red two-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A2) (0.0s)
And there should be a red two-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1133" name="Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="241418053" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000704" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1b+A2
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4a93fccd-6c52-1514-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1b+A2") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1134" name="Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1883529867" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000735" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1b+A2b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/3962528d-7dc8-32ef-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1b+A2b") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1135" name="Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;c&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;c&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1963538376" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000693" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1b+A2c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/05cd53cd-b22a-8c80-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1b+A2c") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1136" name="Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;k&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;k&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="925652177" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000740" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1b+A2k
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/c106aacd-f801-03ec-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1b+A2k") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1137" name="Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="935702684" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000738" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1b+A2+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/224f3624-d898-318b-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1b+A2+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1138" name="Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1079716986" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000743" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1b+A2b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/111d8be4-ea0e-4f66-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1b+A2b+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1139" name="Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;c+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;c+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="951330848" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000707" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1b+A2c+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/dd888d24-1e6f-a8f8-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1b+A2c+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1140" name="Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;k+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;b+&quot;,&quot;k+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1661898918" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000715" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1b+A2k+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/98c1e424-6447-2064-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1b+A2k+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "three", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1141" name="Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;one-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;one-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="395867821" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000678" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1c+A2
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/57f73d8d-f59a-f991-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1c+A2") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red one-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A2) (0.0s)
And there should be a red cursed two-stack on a1
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1142" name="Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1035269375" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000696" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1c+A2b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/46c5934d-0710-176d-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1c+A2b") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1143" name="Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;c&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;cursed one-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;c&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;cursed one-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="2119793149" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001629" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1c+A2c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/1330948d-3b72-70fe-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1c+A2c") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red cursed one-stack on a2
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "one", A2) (0.0s)
And there should be a red cursed two-stack on a1
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1144" name="Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;k&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;one-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;k&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;one-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="2037172834" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000753" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1c+A2k
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/ce69eb8d-8149-e86a-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1c+A2k") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red one-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", A2) (0.0s)
And there should be a red cursed two-stack on a1
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1145" name="Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1680804673" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000663" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1c+A2+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/2fb276e4-61e0-1609-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1c+A2+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red two-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A2) (0.0s)
And there should be a red cursed two-stack on a1
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1146" name="Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1177920924" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000748" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1c+A2b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/1e80cca4-7356-33e4-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1c+A2b+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A2) (0.0s)
And there should be a red one-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1147" name="Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;c+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;cursed two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;c+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;cursed two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1425163051" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000750" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1c+A2c+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/eaebcde4-a7b7-8d75-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1c+A2c+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red cursed two-stack on a2
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A2) (0.0s)
And there should be a red cursed two-stack on a1
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1148" name="Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;c+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1900653277" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000695" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1c+A2k+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/a62524e4-ed8f-04e1-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1c+A2k+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red two-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A2) (0.0s)
And there should be a red cursed two-stack on a1
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1149" name="Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1305917904" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000865" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1k+A2
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/bf263e8d-574f-2a39-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1k+A2") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A2) (0.0s)
And there should be a red one-stack king on a1
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1150" name="Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="794427958" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000784" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1k+A2b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/adf4944d-68c5-4814-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1k+A2b") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A2) (0.0s)
And there should be a red one-stack king on a1
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1151" name="Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;c&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;cursed one-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;c&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;cursed one-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1768272027" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000748" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1k+A2c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/7a5f958d-9d27-a1a5-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1k+A2c") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red cursed one-stack on a2
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "one", A2) (0.0s)
And there should be a red two-stack king on a1
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1152" name="Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;k&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;one-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;k&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;one-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1171417501" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000717" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1k+A2k
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/3598ec8d-e2ff-1911-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1k+A2k") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Kings Cannot Merge With Kings
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Kings Cannot Merge With Kings
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red one-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", A2) (0.0s)
And there should be a red two-stack king on a1
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1153" name="Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;+&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;+&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="573916717" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000715" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1k+A2+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/96e177e4-c395-46b0-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1k+A2+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red two-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A2) (0.0s)
And there should be a red two-stack king on a1
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1154" name="Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;three-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;three-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1708509200" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000731" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1k+A2b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/85afcda4-d50b-648b-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1k+A2b+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Accepted: a1-1-a2
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "three", A2) (0.0s)
And there should be a red one-stack king on a1
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1155" name="Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;c+&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;cursed two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;c+&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;cursed two-stack&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="2088969034" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000795" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1k+A2c+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/521acee4-096d-be1d-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1k+A2c+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red cursed two-stack on a2
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A2) (0.0s)
And there should be a red two-stack king on a1
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1156" name="Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_Adjacent(&quot;k+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_Adjacent" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1662591724" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000690" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: A1k+A2k+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/0d5425e4-4f45-3589-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "A1k+A2k+") (0.0s)
When the red player splits 1 piece from a1 onto a2
Rejected: a1-1-a2: Kings Cannot Merge With Kings
-> done: ActionSteps.WhenISplit(Red, "1", A1, A2) (0.0s)
Then the action fails
Failed with: Kings Cannot Merge With Kings
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red two-stack king on a2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A2) (0.0s)
And there should be a red two-stack king on a1
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A1) (0.0s)
]]></output>
                  </test-case>
                </test-suite>
                <test-suite type="ParameterizedMethod" id="0-1124" name="Split_MergeRuleTest_OverWall" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" testcasecount="32" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.026754" total="32" passed="32" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="240">
                  <properties>
                    <property name="Description" value="Split-Merge Rule Test - Over Wall" />
                  </properties>
                  <test-case id="0-1092" name="Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1694638203" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001527" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9+A5
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/df62d1f4-d66a-971b-778a-1a47fd7ffbea.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9+A5") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1093" name="Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="521635924" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000727" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9+A5b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-778a-1a47fd7ffbea.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9+A5b") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1094" name="Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;c&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;c&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="184742740" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000710" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9+A5c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/899df2f4-0c67-8eea-778a-1a47fd7ffbea.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9+A5c") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1095" name="Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;k&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;k&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="525443267" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000711" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9+A5k
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/33d913f4-4264-86b8-778a-1a47fd7ffbea.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9+A5k") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king on a5
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1096" name="Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="2082536520" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000706" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9+A5+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/dc0d0d15-a4a0-2d13-778a-1a47fd7ffbea.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9+A5+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1097" name="Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="322355176" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000742" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9+A5b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/069bd555-3220-ab07-778a-1a47fd7ffbea.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9+A5b+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1098" name="Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;c+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;c+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="555012268" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001538" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9+A5c+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/86482e15-da9d-24e1-778a-1a47fd7ffbea.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9+A5c+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1099" name="Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;k+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;+&quot;,&quot;k+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack king&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="646737566" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000726" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9+A5k+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/30834f15-109a-1cb0-778a-1a47fd7ffbea.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9+A5k+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king on a5
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "three", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1100" name="Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="529105059" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000711" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9b+A5
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/df62d1f4-d66a-971b-37e8-e1c82c21b96f.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9b+A5") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1101" name="Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="542476881" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000706" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9b+A5b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-37e8-e1c82c21b96f.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9b+A5b") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1102" name="Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;c&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;c&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1805721818" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000697" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9b+A5c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/899df2f4-0c67-8eea-37e8-e1c82c21b96f.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9b+A5c") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1103" name="Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;k&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;k&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="878198020" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000709" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9b+A5k
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/33d913f4-4264-86b8-37e8-e1c82c21b96f.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9b+A5k") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king on a5
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1104" name="Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1917642991" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000703" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9b+A5+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/dc0d0d15-a4a0-2d13-37e8-e1c82c21b96f.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9b+A5+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1105" name="Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1613427181" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000701" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9b+A5b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/069bd555-3220-ab07-37e8-e1c82c21b96f.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9b+A5b+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1106" name="Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;c+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;c+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="186935310" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000703" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9b+A5c+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/86482e15-da9d-24e1-37e8-e1c82c21b96f.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9b+A5c+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1107" name="Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;k+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;b+&quot;,&quot;k+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack king&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="2010304798" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000731" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9b+A5k+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/30834f15-109a-1cb0-37e8-e1c82c21b96f.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9b+A5k+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king on a5
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "three", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1108" name="Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;one-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;one-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="179366668" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000670" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9c+A5
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/df62d1f4-d66a-971b-7701-384ebb04f2fd.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9c+A5") (0.0s)
When the red player splits 1 piece from e9 onto a5
Rejected: e9-1-a5: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red one-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", A5) (0.0s)
And there should be a red cursed two-stack on e9
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1109" name="Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1017149788" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000701" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9c+A5b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-7701-384ebb04f2fd.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9c+A5b") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1110" name="Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;c&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;cursed one-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;c&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;cursed one-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1346336178" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000677" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9c+A5c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/899df2f4-0c67-8eea-7701-384ebb04f2fd.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9c+A5c") (0.0s)
When the red player splits 1 piece from e9 onto a5
Rejected: e9-1-a5: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red cursed one-stack on a5
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "one", A5) (0.0s)
And there should be a red cursed two-stack on e9
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1111" name="Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;k&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;one-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;k&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;one-stack king&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="64519790" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000729" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9c+A5k
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/33d913f4-4264-86b8-7701-384ebb04f2fd.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9c+A5k") (0.0s)
When the red player splits 1 piece from e9 onto a5
Rejected: e9-1-a5: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red one-stack king on a5
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", A5) (0.0s)
And there should be a red cursed two-stack on e9
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1112" name="Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;two-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1015751596" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000754" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9c+A5+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/dc0d0d15-a4a0-2d13-7701-384ebb04f2fd.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9c+A5+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Rejected: e9-1-a5: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red two-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", A5) (0.0s)
And there should be a red cursed two-stack on e9
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1113" name="Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack&quot;,&quot;three-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="28178048" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000732" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9c+A5b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/069bd555-3220-ab07-7701-384ebb04f2fd.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9c+A5b+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on a5
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A5) (0.0s)
And there should be a red one-stack on e9
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1114" name="Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;c+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;cursed two-stack&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;c+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;cursed two-stack&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="844465157" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000680" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9c+A5c+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/86482e15-da9d-24e1-7701-384ebb04f2fd.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9c+A5c+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Rejected: e9-1-a5: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red cursed two-stack on a5
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", A5) (0.0s)
And there should be a red cursed two-stack on e9
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1115" name="Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;c+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;cursed two-stack&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="94549097" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000736" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9c+A5k+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/30834f15-109a-1cb0-7701-384ebb04f2fd.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9c+A5k+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Rejected: e9-1-a5: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red two-stack king on a5
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A5) (0.0s)
And there should be a red cursed two-stack on e9
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1116" name="Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king with a blessing&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king with a blessing&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1296582668" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001484" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9k+A5
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/df62d1f4-d66a-971b-7778-55557989e810.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9k+A5") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king with a blessing on a5
-> done: ValidationSteps.ThenThereShouldBeBlessedKing(Red, "two", A5) (0.0s)
And there should be a red one-stack king on e9
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1117" name="Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king with a blessing&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;b&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king with a blessing&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1759221571" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000767" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9k+A5b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-7778-55557989e810.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9k+A5b") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king with a blessing on a5
-> done: ValidationSteps.ThenThereShouldBeBlessedKing(Red, "two", A5) (0.0s)
And there should be a red one-stack king on e9
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1118" name="Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;c&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king with a blessing&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;c&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;two-stack king with a blessing&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="2106338795" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000715" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9k+A5c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/899df2f4-0c67-8eea-7778-55557989e810.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9k+A5c") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king with a blessing on a5
-> done: ValidationSteps.ThenThereShouldBeBlessedKing(Red, "two", A5) (0.0s)
And there should be a red one-stack king on e9
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1119" name="Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;k&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;one-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;k&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;one-stack king&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="304720491" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000670" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9k+A5k
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/33d913f4-4264-86b8-7778-55557989e810.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9k+A5k") (0.0s)
When the red player splits 1 piece from e9 onto a5
Rejected: e9-1-a5: Kings Cannot Merge With Kings
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action fails
Failed with: Kings Cannot Merge With Kings
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red one-stack king on a5
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", A5) (0.0s)
And there should be a red two-stack king on e9
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1120" name="Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;+&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;three-stack king with a blessing&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;+&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;three-stack king with a blessing&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="616529736" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000695" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9k+A5+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/dc0d0d15-a4a0-2d13-7778-55557989e810.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9k+A5+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king with a blessing on a5
-> done: ValidationSteps.ThenThereShouldBeBlessedKing(Red, "three", A5) (0.0s)
And there should be a red one-stack king on e9
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1121" name="Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;three-stack king with a blessing&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;b+&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;three-stack king with a blessing&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1204751607" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000706" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9k+A5b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/069bd555-3220-ab07-7778-55557989e810.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9k+A5b+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king with a blessing on a5
-> done: ValidationSteps.ThenThereShouldBeBlessedKing(Red, "three", A5) (0.0s)
And there should be a red one-stack king on e9
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1122" name="Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;c+&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;three-stack king with a blessing&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;c+&quot;,&quot;succeeds&quot;,&quot;one-stack king&quot;,&quot;three-stack king with a blessing&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1623734112" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000792" asserts="7">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9k+A5c+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/86482e15-da9d-24e1-7778-55557989e810.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9k+A5c+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Accepted: e9-1-a5
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king with a blessing on a5
-> done: ValidationSteps.ThenThereShouldBeBlessedKing(Red, "three", A5) (0.0s)
And there should be a red one-stack king on e9
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", E9) (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1123" name="Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;two-stack king&quot;,null)" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeRuleTest_OverWall(&quot;k+&quot;,&quot;k+&quot;,&quot;fails&quot;,&quot;two-stack king&quot;,&quot;two-stack king&quot;,null)" methodname="Split_MergeRuleTest_OverWall" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="2092206348" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000702" asserts="9">
                    <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B C6 |
  | R:A5bD8bE1c2k8cF8I5       |
  | B:C6k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/09f19a34-63ea-150f-a9a0-280a5cc276f4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
And I add these red pieces: E9k+A5k+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/30834f15-109a-1cb0-7778-55557989e810.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "E9k+A5k+") (0.0s)
When the red player splits 1 piece from e9 onto a5
Rejected: e9-1-a5: Kings Cannot Merge With Kings
-> done: ActionSteps.WhenISplit(Red, "1", E9, A5) (0.0s)
Then the action fails
Failed with: Kings Cannot Merge With Kings
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And there should be a red two-stack king on a5
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", A5) (0.0s)
And there should be a red two-stack king on e9
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", E9) (0.0s)
]]></output>
                  </test-case>
                </test-suite>
                <test-case id="0-1080" name="Split_MoveCannotMoveOntoBlock" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MoveCannotMoveOntoBlock" methodname="Split_MoveCannotMoveOntoBlock" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="377487846" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001337" asserts="4">
                  <properties>
                    <property name="Description" value="Split-Move Cannot Move Onto Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12+            |
  | B:D78E78k9F78             |
  | X:F3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-9847-d0636e10e2b0.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from f2 onto f3
Rejected: f2-1-f3: Stack Size 1 Piece At F2 Cannot Reach F3 (but can reach: F1)
-> done: ActionSteps.WhenISplit(Red, "1", F2, F3) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F2 Cannot Reach F3 (but can reach: F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1081" name="Split_MoveCannotMoveOverBlock" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MoveCannotMoveOverBlock" methodname="Split_MoveCannotMoveOverBlock" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1947398072" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001101" asserts="4">
                  <properties>
                    <property name="Description" value="Split-Move Cannot Move Over Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12+++          |
  | B:D78E78k9F78             |
  | X:F3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-2629-0274ebe04ae7.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from f2 onto f4
Rejected: f2-2-f4: Stack Size 2 Piece At F2 Cannot Reach F4 (but can reach: F1)
-> done: ActionSteps.WhenISplit(Red, "2", F2, F4) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At F2 Cannot Reach F4 (but can reach: F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1079" name="Split_MoveCursesBothPieces" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MoveCursesBothPieces" methodname="Split_MoveCursesBothPieces" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1570884827" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001250" asserts="7">
                  <properties>
                    <property name="Description" value="Split-Move Curses Both Pieces" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at f1 into f2
Accepted: f1+f2
-> done: ActionSteps.WhenIMerge(Red, F1, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player splits 1 piece from f2 onto f3
Accepted: f2-1-f3
-> done: ActionSteps.WhenISplit(Red, "1", F2, F3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3F2c3c
Successfully validated 7 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F2c3c") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1074" name="Split_MoveHappyPath" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MoveHappyPath" methodname="Split_MoveHappyPath" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="322934736" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001189" asserts="6">
                  <properties>
                    <property name="Description" value="Split-Move Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
And the red player splits 1 piece from f2 onto f3
Accepted: f2-1-f3
-> done: ActionSteps.WhenISplit(Red, "1", F2, F3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12kF12c3c
Successfully validated 7 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12kF12c3c") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1078" name="SplitDistanceCannotExceedSize" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.SplitDistanceCannotExceedSize" methodname="SplitDistanceCannotExceedSize" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="134767479" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001531" asserts="20">
                  <properties>
                    <property name="Description" value="Split Distance Cannot Exceed Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D1b+2b+++E1+2k3b+F12b++ |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/d58e0304-44f3-a94f-0f30-0c399122a905.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from e3 onto e5
Rejected: e3-1-e5: Stack Size 1 Piece At E3 Cannot Reach E5 (but can reach: E4, E2)
-> done: ActionSteps.WhenISplit(Red, "1", E3, E5) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E3 Cannot Reach E5 (but can reach: E4, E2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 2 pieces from f2 onto f5
Rejected: f2-2-f5: Stack Size 2 Piece At F2 Cannot Reach F5 (but can reach: F3, F4, F1)
-> done: ActionSteps.WhenISplit(Red, "2", F2, F5) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At F2 Cannot Reach F5 (but can reach: F3, F4, F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 1 piece from d2 onto d4
Rejected: d2-1-d4: Stack Size 1 Piece At D2 Cannot Reach D4 (but can reach: D3, D1)
-> done: ActionSteps.WhenISplit(Red, "1", D2, D4) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D2 Cannot Reach D4 (but can reach: D3, D1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 2 pieces from d2 onto d5
Rejected: d2-2-d5: Stack Size 2 Piece At D2 Cannot Reach D5 (but can reach: D3, D4, D1)
-> done: ActionSteps.WhenISplit(Red, "2", D2, D5) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At D2 Cannot Reach D5 (but can reach: D3, D4, D1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 3 pieces from d2 onto d6
Rejected: d2-3-d6: Stack Size 3 Piece At D2 Cannot Reach D6 (but can reach: D3, D4, D5, D1)
-> done: ActionSteps.WhenISplit(Red, "3", D2, D6) (0.0s)
Then the action fails
Failed with: Stack Size 3 Piece At D2 Cannot Reach D6 (but can reach: D3, D4, D5, D1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1077" name="SplitMustRejectInvalidSizes" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.SplitMustRejectInvalidSizes" methodname="SplitMustRejectInvalidSizes" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="953027255" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001378" asserts="22">
                  <properties>
                    <property name="Description" value="Split Must Reject Invalid Sizes" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board LargeStacks
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/f63607a3-2d9b-16ec-f2e3-88e1c92baf0d.png?raw=true)
Loaded board LargeStacks.
-> done: SetupSteps.GivenIHaveNamedBoard("LargeStacks") (0.0s)
When the red player splits 0 pieces from d2 onto d3
Rejected: d2-0-d3: Must Split At Least One Piece
-> done: ActionSteps.WhenISplit(Red, "0", D2, D3) (0.0s)
Then the action fails
Failed with: Must Split At Least One Piece
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 15 pieces from d2 onto d3
Rejected: d2-15-d3: Must Leave At Least One Piece Behind When Splitting
-> done: ActionSteps.WhenISplit(Red, "15", D2, D3) (0.0s)
Then the action fails
Failed with: Must Leave At Least One Piece Behind When Splitting
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits -47 pieces from d2 onto d3
Rejected: d2--47-d3: Must Split At Least One Piece
-> done: ActionSteps.WhenISplit(Red, "-47", D2, D3) (0.0s)
Then the action fails
Failed with: Must Split At Least One Piece
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 8675309 pieces from d2 onto d3
Rejected: d2-8675309-d3: Must Leave At Least One Piece Behind When Splitting
-> done: ActionSteps.WhenISplit(Red, "8675309", D2, D3) (0.0s)
Then the action fails
Failed with: Must Leave At Least One Piece Behind When Splitting
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 16 pieces from d2 onto d3
Rejected: d2-16-d3: Must Leave At Least One Piece Behind When Splitting
-> done: ActionSteps.WhenISplit(Red, "16", D2, D3) (0.0s)
Then the action fails
Failed with: Must Leave At Least One Piece Behind When Splitting
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1158" name="WinLoseRulesFeature" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" testcasecount="16" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.037961" total="16" passed="16" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="64">
                <properties>
                  <property name="Description" value="Win Lose Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1162" name="BlueCapturingAnyRedKingCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueCapturingAnyRedKingCausesBlueWin" methodname="BlueCapturingAnyRedKingCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1411503434" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001652" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Capturing Any Red King Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:D123k+F3+H2+            |
  | B:B3kC3kD5+E9F78          |
  | X:B2D4F4                  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/5c64c75d-8973-90e1-0a08-60b30e80d4db.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at c3 to d3
Accepted: c3d3
-> done: ActionSteps.WhenIMove(Blue, C3, D3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1164" name="BlueFormingChainWithKingCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueFormingChainWithKingCausesBlueWin" methodname="BlueFormingChainWithKingCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="223649369" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001491" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Forming Chain With King Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B=E8 |
  | R:D123k+E4c5cF5cG2c5cH2c  |
  | B:A1c2cB3k4k5C6D8+E9F8+   |
  | X:B2C7D4F246H3I4          |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/aa5131bb-7b59-b9e2-c253-8f62ee24de31.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player places a piece at d7
Accepted: @d7
-> done: ActionSteps.WhenIDrop(Blue, D7) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1166" name="BlueJoiningKingToExistingChainCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueJoiningKingToExistingChainCausesRedWin" methodname="BlueJoiningKingToExistingChainCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1454562316" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001149" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Joining King To Existing Chain Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:E3k+I1b2b3b+4c5c        |
  | B:A1c2c3b4b5b+D7k+        |
  | X:E46G36H4                |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/9119f1a9-7740-babf-c99c-5f676bf1e5cd.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece from d7 to b5
Accepted: d7b5
-> done: ActionSteps.WhenIMove(Blue, D7, B5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1160" name="BlueKingPassingRedWallCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueKingPassingRedWallCausesBlueWin" methodname="BlueKingPassingRedWallCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1527076956" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001774" asserts="4">
                  <properties>
                    <property name="Description" value="Blue King Passing Red Wall Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:D12F2k+3+H2+            |
  | B:A2k+D5+E9F78            |
  | X:B2D4F4                  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/806ef28b-ddbc-7ae0-7890-91f86cd59ae1.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at a2 to a5
Accepted: a2a5
-> done: ActionSteps.WhenIMove(Blue, A2, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1170" name="BlueMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" methodname="BlueMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1232079994" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.014659" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Moving Blessed Piece Onto Blue Home Does Not Cause Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:E3k+G1b+2bI2b4c5c       |
  | B:A1c2c3b4bD7b+F8k+       |
  | X:A5E46G36H4              |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/e19fd377-f67f-2d55-8395-2e2db365f5bc.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece from d7 to e8
Accepted: d7e8
-> done: ActionSteps.WhenIMove(Blue, D7, E8) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a blue king on e8 without any blessing
-> done: ValidationSteps.ThenThereShouldBeKingNoSize(Blue, E8) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1169" name="BlueMovingBlessedPieceOntoRedHomeDoesNotCauseWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueMovingBlessedPieceOntoRedHomeDoesNotCauseWin" methodname="BlueMovingBlessedPieceOntoRedHomeDoesNotCauseWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="2008634310" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001301" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Moving Blessed Piece Onto Red Home Does Not Cause Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:F2b7b+G2k+H3bI4c5c      |
  | B:A2c3bB3c5+D2b+F8k+      |
  | X:A5E46G36H4              |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/2152496e-58d6-0f73-0fb8-8cbcc6ef0c05.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves a piece from d2 to e2
Accepted: d2e2
-> done: ActionSteps.WhenIMove(Blue, D2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a blue king on e2 without any blessing
-> done: ValidationSteps.ThenThereShouldBeKingNoSize(Blue, E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1174" name="BlueWinWithNoLegalMovesCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueWinWithNoLegalMovesCausesBlueWin" methodname="BlueWinWithNoLegalMovesCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1669325745" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001252" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Win With No Legal Moves Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:A2kD7cE12k78k9cF17c     |
  | B:B3k                     |
  | X:A135C16D358F358G16H2I35 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/68d3827a-ccd4-bbfe-f88f-d047f6a5200f.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece from b3 to a2
Accepted: b3a2
-> done: ActionSteps.WhenIMove(Blue, B3, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1173" name="BlueWithNoLegalMovesCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueWithNoLegalMovesCausesRedWin" methodname="BlueWithNoLegalMovesCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="2078589103" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.003990" asserts="4">
                  <properties>
                    <property name="Description" value="Blue With No Legal Moves Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:D7cE12k78k9cF17c        |
  | B:B3k                     |
  | X:A135C16D358F358G16H2I35 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/233e7043-4c24-21c1-f88f-d047f6a5200f.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece from b3 to a2
Accepted: b3a2
-> done: ActionSteps.WhenIMove(Blue, B3, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1161" name="RedCapturingAnyBlueKingCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedCapturingAnyBlueKingCausesRedWin" methodname="RedCapturingAnyBlueKingCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="957026179" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001153" asserts="4">
                  <properties>
                    <property name="Description" value="Red Capturing Any Blue King Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:D123k+F3+H2+            |
  | B:B3kC3kD5+E9F78          |
  | X:B2D4F4                  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/5c64c75d-8973-90e1-3cb1-0a5eb92a7f86.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at d3 to c3
Accepted: d3c3
-> done: ActionSteps.WhenIMove(Red, D3, C3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1163" name="RedFormingChainWithKingCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedFormingChainWithKingCausesRedWin" methodname="RedFormingChainWithKingCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1822080223" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001175" asserts="4">
                  <properties>
                    <property name="Description" value="Red Forming Chain With King Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:D123k+E4c5cF5cG5cH5+    |
  | B:B3k4k5+D78+E79F8+       |
  | X:B2C7D4F46               |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/78b380ba-c28e-6413-4b8d-a0dbc6191418.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits one piece from h5 to h6
Accepted: h5-1-h6
-> done: ActionSteps.WhenISplit(Red, "one", H5, H6) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1165" name="RedJoiningKingToExistingChainCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedJoiningKingToExistingChainCausesRedWin" methodname="RedJoiningKingToExistingChainCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="315088032" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001086" asserts="4">
                  <properties>
                    <property name="Description" value="Red Joining King To Existing Chain Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:F2k+I1b2b3b+4c5c        |
  | B:A1c2c4+5+E8k            |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/8a411d4b-e3f1-2467-439c-20608293af28.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece from f2 to h2
Accepted: f2h2
-> done: ActionSteps.WhenIMove(Red, F2, H2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1159" name="RedKingPassingBlueWallCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedKingPassingBlueWallCausesRedWin" methodname="RedKingPassingBlueWallCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="13369028" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001085" asserts="4">
                  <properties>
                    <property name="Description" value="Red King Passing Blue Wall Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12I5k          |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-02fe-05096143b446.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at i5 to a1
Accepted: i5a1
-> done: ActionSteps.WhenIMove(Red, I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1168" name="RedMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" methodname="RedMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1401077349" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001127" asserts="4">
                  <properties>
                    <property name="Description" value="Red Moving Blessed Piece Onto Blue Home Does Not Cause Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:F2b7b+G2k+H3bI4c5c      |
  | B:A2c3bB3c5+D2b+F8k+      |
  | X:A5E46G36H4              |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/2152496e-58d6-0f73-4161-3767719ab7af.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves a piece from f7 to e8
Accepted: f7e8
-> done: ActionSteps.WhenIMove(Red, F7, E8) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red king on e8 without any blessing
-> done: ValidationSteps.ThenThereShouldBeKingNoSize(Red, E8) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1167" name="RedMovingBlessedPieceOntoRedHomeDoesNotCauseWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedMovingBlessedPieceOntoRedHomeDoesNotCauseWin" methodname="RedMovingBlessedPieceOntoRedHomeDoesNotCauseWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="329143021" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002112" asserts="4">
                  <properties>
                    <property name="Description" value="Red Moving Blessed Piece Onto Red Home Does Not Cause Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:C2b+D123E13F12k         |
  | B:C5+D7E7+8kF8+           |
  | X:B6D6F5H3                |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/6ef9465f-58c1-ad99-27ac-8fc45b030ce9.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece from c2 to e2
Accepted: c2e2
-> done: ActionSteps.WhenIMove(Red, C2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a two-stack king on e2 without any blessing
-> done: ValidationSteps.ThenThereShouldBeKingNoColor("two", E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1172" name="RedWinWithNoLegalMovesCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedWinWithNoLegalMovesCausesRedWin" methodname="RedWinWithNoLegalMovesCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1812110140" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001148" asserts="4">
                  <properties>
                    <property name="Description" value="Red Win With No Legal Moves Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1k                     |
  | B:A2kD2+E1k2k3c8k9F2c7    |
  | X:B246D168E4F18G35H16I24  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/65fdeb72-42a9-fa6f-5271-c7afd0c8b92a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece from a1 to a2
Accepted: a1a2
-> done: ActionSteps.WhenIMove(Red, A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1171" name="RedWithNoLegalMovesCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedWithNoLegalMovesCausesBlueWin" methodname="RedWithNoLegalMovesCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="333301770" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001212" asserts="4">
                  <properties>
                    <property name="Description" value="Red With No Legal Moves Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1k                     |
  | B:D2+E1k2k3c8k9F2c7       |
  | X:B246D168E4F18G35H16I24  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/17d0041b-4ab4-ef1f-5271-c7afd0c8b92a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece from a1 to a2
Accepted: a1a2
-> done: ActionSteps.WhenIMove(Red, A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1175" name="WrapAroundRulesFeature" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" testcasecount="21" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.029493" total="21" passed="21" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="129">
                <properties>
                  <property name="Description" value="Wrap Around Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1187" name="BlessedPieceWrappingAroundAndMergingCanFormAnyStackSize" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundAndMergingCanFormAnyStackSize" methodname="BlessedPieceWrappingAroundAndMergingCanFormAnyStackSize" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1194722129" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001964" asserts="8">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around and Merging Can Form Any Stack Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                        |
  | Benediction v1: R-E2 B E8    |
  | R:A2c++D12E12k3F12G1+7bH6b++ |
  | B:D78E78k9F78                |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/86149e11-482f-6767-f9c5-3f3c8a80fb3e.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at g7 onto g1
Accepted: g7+g1
-> done: ActionSteps.WhenIMerge(Red, G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on g1
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", G1) (0.0s)
When the red player merges the piece at h6 onto a2
Accepted: h6+a2
-> done: ActionSteps.WhenIMerge(Red, H6, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red six-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "six", A2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1194" name="BlessedPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" methodname="BlessedPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1400869356" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001259" asserts="6">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around and Split Merging Can Form Any Stack Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1+D12E12k3F12I5b+      |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/63f6ae4e-6fc5-141d-63bf-c8db1c33036b.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from i5 onto a1
Accepted: i5-1-a1
-> done: ActionSteps.WhenISplit(Red, "1", I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red one-stack on i5
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", I5) (0.0s)
And there should be a red three-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1191" name="BlessedPieceWrappingAroundAndSplittingCompletingBridgeLeavesBless_BlessPair" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundAndSplittingCompletingBridgeLeavesBless_BlessPair" methodname="BlessedPieceWrappingAroundAndSplittingCompletingBridgeLeavesBless_BlessPair" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="232899710" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002322" asserts="20">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around and Splitting Completing Bridge Leaves Bless-Bless Pair" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                       |
  | Benediction v1: R-E2 B E8   |
  | R:A5+B5C5D125E12k35F124G3H2 |
  | B:D78E78k9F78               |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/5aeeb02e-79b6-79a2-0079-3ae201be036b.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from a5 onto i1
Accepted: a5-1-i1
-> done: ActionSteps.WhenISplit(Red, "1", A5, I1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red blessed one-stack on a5
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", A5) (0.0s)
And there should be a red blessed one-stack on b5
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", B5) (0.0s)
And there should be a red blessed one-stack on c5
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", C5) (0.0s)
And there should be a red blessed one-stack on d5
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", D5) (0.0s)
And there should be a red blessed one-stack on e5
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", E5) (0.0s)
And there should be a red blessed one-stack on f4
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", F4) (0.0s)
And there should be a red blessed one-stack on g3
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", G3) (0.0s)
And there should be a red blessed one-stack on h2
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", H2) (0.0s)
And there should be a red blessed one-stack on i1
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", I1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1190" name="BlessedPieceWrappingAroundAndSplittingLeavesBless_CursePair" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundAndSplittingLeavesBless_CursePair" methodname="BlessedPieceWrappingAroundAndSplittingLeavesBless_CursePair" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="619206317" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.002104" asserts="6">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around and Splitting Leaves Bless-Curse Pair" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G7b+++       |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-bd60-40a626c860bf.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from g7 onto g1
Accepted: g7-2-g1
-> done: ActionSteps.WhenISplit(Red, "2", G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red cursed two-stack on g7
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", G7) (0.0s)
And there should be a red blessed two-stack on g1
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "two", G1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1182" name="BlessedPieceWrappingAroundMergingOntoHomeBecomesKing" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundMergingOntoHomeBecomesKing" methodname="BlessedPieceWrappingAroundMergingOntoHomeBecomesKing" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="2112128" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001547" asserts="3">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around Merging Onto Home Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:C1+E2k5+9b+             |
  | B:B6+C3+4k+               |
  | X:A35B2D4                 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b9df848c-0d32-0c2e-4003-0b335d820d16.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at e9 onto e2
Accepted: e9+e2
-> done: ActionSteps.WhenIMerge(Red, E9, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching C1+E2k++5+
Successfully validated 3 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "C1+E2k++5+") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1181" name="BlessedPieceWrappingAroundOntoHomeBecomesKing" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundOntoHomeBecomesKing" methodname="BlessedPieceWrappingAroundOntoHomeBecomesKing" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="962464670" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001151" asserts="3">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around Onto Home Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:C1+D2kE5+9b+            |
  | B:B6+C3+4k+               |
  | X:A35B2D4                 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/eb1e96cc-ef47-6778-4003-0b335d820d16.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at e9 to e2
Accepted: e9e2
-> done: ActionSteps.WhenIMove(Red, E9, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching C1+D2kE2k+5+
Successfully validated 4 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "C1+D2kE2k+5+") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1178" name="BlessedPieceWrappingAroundRemainsBlessed" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundRemainsBlessed" methodname="BlessedPieceWrappingAroundRemainsBlessed" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="118402258" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001079" asserts="6">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around Remains Blessed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
And I add this red piece: I5b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-4284-1edfe6640bd5.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "I5b") (0.0s)
When the red player moves the piece at i5 to a1
Accepted: i5a1
-> done: ActionSteps.WhenIMove(Red, I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: A1bD12E12k3F12
Successfully validated 8 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1bD12E12k3F12") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1185" name="CursedPieceWrappingAroundAndMergingRequiresBlessedTarget" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundAndMergingRequiresBlessedTarget" methodname="CursedPieceWrappingAroundAndMergingRequiresBlessedTarget" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="935568759" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001264" asserts="7">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around and Merging Requires Blessed Target" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:A4b+D128k++E137cF128c   |
  | B:A1k2cB1k3cC2c3cD7F7     |
  | X:A35B2D46F4H246          |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/e954bc1f-3efc-38a0-303a-7c39eba953b0.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece on f8 to f1
Rejected: f8+f1: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenIMerge(Red, F8, F1) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece on f8 to a4
Accepted: f8+a4
-> done: ActionSteps.WhenIMerge(Red, F8, A4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching A4++D128k++E137cF12
Successfully validated 9 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A4++D128k++E137cF12") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1192" name="CursedPieceWrappingAroundAndSplitMergingRequiresBlessedTarget" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundAndSplitMergingRequiresBlessedTarget" methodname="CursedPieceWrappingAroundAndSplitMergingRequiresBlessedTarget" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="797522291" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.000967" asserts="4">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around and Split Merging Requires Blessed Target" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G17c+++      |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-e40d-38982875ea68.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from g7 onto g1
Rejected: g7-1-g1: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", G7, G1) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1188" name="CursedPieceWrappingAroundAndSplittingRemainsCursed" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundAndSplittingRemainsCursed" methodname="CursedPieceWrappingAroundAndSplittingRemainsCursed" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1013705546" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001439" asserts="6">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around and Splitting Remains Cursed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G7c+++       |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-fd01-26ff7662db86.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from g7 onto g1
Accepted: g7-2-g1
-> done: ActionSteps.WhenISplit(Red, "2", G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red cursed two-stack on g7
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", G7) (0.0s)
And there should be a red cursed two-stack on g1
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", G1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1179" name="CursedPieceWrappingAroundOntoHomeBecomesKing" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundOntoHomeBecomesKing" methodname="CursedPieceWrappingAroundOntoHomeBecomesKing" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="610045834" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001161" asserts="3">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around Onto Home Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D1+3E3k+7c9c+           |
  | B:B4C3+6c7cD68G5k         |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/2cd0cdcd-34b2-c073-ce28-8aa5ebaed919.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at e9 to e2
Accepted: e9e2
-> done: ActionSteps.WhenIMove(Red, E9, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D1+3E2k+3k+7c
Successfully validated 5 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D1+3E2k+3k+7c") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1176" name="CursedPieceWrappingAroundRemainsCursed" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundRemainsCursed" methodname="CursedPieceWrappingAroundRemainsCursed" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1277431564" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001150" asserts="6">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around Remains Cursed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
And I add this red piece: I5c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-02dd-ca5e640de64e.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "I5c") (0.0s)
When the red player moves the piece at i5 to a1
Accepted: i5a1
-> done: ActionSteps.WhenIMove(Red, I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: A1cD12E12k3F12
Successfully validated 8 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1cD12E12k3F12") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1196" name="KingStackWrappingAroundAndSplitMergingOntoPieceRemainsBlessedAndWinsGame" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.KingStackWrappingAroundAndSplitMergingOntoPieceRemainsBlessedAndWinsGame" methodname="KingStackWrappingAroundAndSplitMergingOntoPieceRemainsBlessedAndWinsGame" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="788251827" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001339" asserts="8">
                  <properties>
                    <property name="Description" value="King Stack Wrapping Around and Split Merging Onto Piece Remains Blessed and Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1+D12E12k3F12I5k+      |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/63f6ae4e-6fc5-141d-2339-b0059711acdc.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from i5 onto a1
Accepted: i5-1-a1
-> done: ActionSteps.WhenISplit(Red, "1", I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red one-stack king on i5
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "one", I5) (0.0s)
And there should be a red three-stack king with a blessing on a1
-> done: ValidationSteps.ThenThereShouldBeBlessedKing(Red, "three", A1) (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1195" name="KingWrappingAroundAndMergingOntoPieceRemainsBlessedAndWinsGame" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.KingWrappingAroundAndMergingOntoPieceRemainsBlessedAndWinsGame" methodname="KingWrappingAroundAndMergingOntoPieceRemainsBlessedAndWinsGame" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1165834039" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001292" asserts="6">
                  <properties>
                    <property name="Description" value="King Wrapping Around And Merging Onto Piece Remains Blessed and Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1+D12E12k3F12I5k+      |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/63f6ae4e-6fc5-141d-2339-b0059711acdc.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece from i5 onto a1
Accepted: i5+a1
-> done: ActionSteps.WhenIMerge(Red, I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red four-stack king with a blessing on a1
-> done: ValidationSteps.ThenThereShouldBeBlessedKing(Red, "four", A1) (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1184" name="KingWrappingAroundOntoHomeWinsGame" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.KingWrappingAroundOntoHomeWinsGame" methodname="KingWrappingAroundOntoHomeWinsGame" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="62573438" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001152" asserts="4">
                  <properties>
                    <property name="Description" value="King Wrapping Around Onto Home Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:E7+8k++                 |
  | B:B3+6+C1k2k              |
  | X:A35B2D46                |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/0613b08b-4a83-ccbd-ca4a-afbfeae43b72.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece on e8 to e2
Accepted: e8e2
-> done: ActionSteps.WhenIMove(Red, E8, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1183" name="KingWrappingAroundOntoRegularSpaceWinsGame" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.KingWrappingAroundOntoRegularSpaceWinsGame" methodname="KingWrappingAroundOntoRegularSpaceWinsGame" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1449943145" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001109" asserts="4">
                  <properties>
                    <property name="Description" value="King Wrapping Around Onto Regular Space Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:E7+H5k++                |
  | B:B6+C1k2k3+              |
  | X:A35B2D4                 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/c540c5bb-b595-2245-fae5-a54b833ee5f9.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece on c1 to c7
Accepted: c1c7
-> done: ActionSteps.WhenIMove(Blue, C1, C7) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1177" name="NormalPieceWrappingAroundBecomesBlessed" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.NormalPieceWrappingAroundBecomesBlessed" methodname="NormalPieceWrappingAroundBecomesBlessed" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1447228739" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001241" asserts="6">
                  <properties>
                    <property name="Description" value="Normal Piece Wrapping Around Becomes Blessed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-c11c-9e2272422602.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
And I add this red piece: I5
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-02bc-8fb467d71757.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "I5") (0.0s)
When the red player moves the piece at i5 to a1
Accepted: i5a1
-> done: ActionSteps.WhenIMove(Red, I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: A1bD12E12k3F12
Successfully validated 8 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1bD12E12k3F12") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1180" name="NormalPieceWrappingAroundOntoHomeBecomesKing" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.NormalPieceWrappingAroundOntoHomeBecomesKing" methodname="NormalPieceWrappingAroundOntoHomeBecomesKing" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1115544376" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001149" asserts="3">
                  <properties>
                    <property name="Description" value="Normal Piece Wrapping Around Onto Home Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:E2k+3k+47cG4+           |
  | B:B4C6c7cD678E1+H4k       |
  | X:G3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/9fbe3c84-8238-9d08-018d-247974130c96.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at e1 to e8
Accepted: e1e8
-> done: ActionSteps.WhenIMove(Blue, E1, E8) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has blue pieces matching B4C6c7cD678E8k+H4k
Successfully validated 8 Blue pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Blue, "B4C6c7cD678E8k+H4k") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1186" name="RegularPieceWrappingAroundAndMergingCanFormAnyStackSize" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.RegularPieceWrappingAroundAndMergingCanFormAnyStackSize" methodname="RegularPieceWrappingAroundAndMergingCanFormAnyStackSize" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="219412822" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001445" asserts="8">
                  <properties>
                    <property name="Description" value="Regular Piece Wrapping Around and Merging Can Form Any Stack Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                      |
  | Benediction v1: R-E2 B E8  |
  | R:A2c++D12E12k3F12G1+7H6++ |
  | B:D78E78k9F78              |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/86149e11-482f-6767-f95b-29c60870b39a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at g7 onto g1
Accepted: g7+g1
-> done: ActionSteps.WhenIMerge(Red, G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on g1
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", G1) (0.0s)
When the red player merges the piece at h6 onto a2
Accepted: h6+a2
-> done: ActionSteps.WhenIMerge(Red, H6, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red six-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "six", A2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1193" name="RegularPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.RegularPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" methodname="RegularPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="241287678" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001444" asserts="6">
                  <properties>
                    <property name="Description" value="Regular Piece Wrapping Around and Split Merging Can Form Any Stack Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1+D12E12k3F12I5+       |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/63f6ae4e-6fc5-141d-23f7-39b19da50fed.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from i5 onto a1
Accepted: i5-1-a1
-> done: ActionSteps.WhenISplit(Red, "1", I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red one-stack on i5
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", I5) (0.0s)
And there should be a red three-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1189" name="RegularPieceWrappingAroundAndSplittingLeavesBless_CursePair" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.RegularPieceWrappingAroundAndSplittingLeavesBless_CursePair" methodname="RegularPieceWrappingAroundAndSplittingLeavesBless_CursePair" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1664278486" result="Passed" start-time="2020-05-03 00:09:24Z" end-time="2020-05-03 00:09:24Z" duration="0.001263" asserts="6">
                  <properties>
                    <property name="Description" value="Regular Piece Wrapping Around and Splitting Leaves Bless-Curse Pair" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G7+++        |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4c42702c-34cb-0ba7-fd2a-4933613f8d27.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from g7 onto g1
Accepted: g7-2-g1
-> done: ActionSteps.WhenISplit(Red, "2", G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red cursed two-stack on g7
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", G7) (0.0s)
And there should be a red blessed two-stack on g1
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "two", G1) (0.0s)
]]></output>
                </test-case>
              </test-suite>
            </test-suite>
          </test-suite>
        </test-suite>
      </test-suite>
    </test-suite>
  </test-suite>
</test-run>