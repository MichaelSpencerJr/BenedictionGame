<?xml version="1.0" encoding="utf-8" standalone="no"?>
<test-run id="2" testcasecount="118" result="Passed" total="118" passed="115" failed="0" inconclusive="3" skipped="0" asserts="1106" engine-version="3.10.0.0" clr-version="4.0.30319.42000" start-time="2020-02-08 19:21:41Z" end-time="2020-02-08 19:21:45Z" duration="3.298497">
  <command-line><![CDATA["C:\ProgramData\chocolatey\lib\nunit-console-runner\tools\nunit3-console.exe" ..\..\src\Testing\Specflow\bin\Debug\Testing.Specflow.dll --result=report.txt;transform=..\..\..\nunit-transforms\nunit3-summary\text-report.xslt --result=report.html;transform=..\..\..\nunit-transforms\nunit3-summary\html-report.xslt --result=readme.md;transform=..\md-report.xslt --result=TestResult.xml]]></command-line>
  <test-suite type="Assembly" id="0-1130" name="Testing.Specflow.dll" fullname="F:\src\BenedictionGame\src\Testing\Specflow\bin\Debug\Testing.Specflow.dll" runstate="Runnable" testcasecount="118" result="Passed" start-time="2020-02-08 19:21:42Z" end-time="2020-02-08 19:21:45Z" duration="2.862098" total="118" passed="115" failed="0" warnings="0" inconclusive="3" skipped="0" asserts="1106">
    <environment framework-version="3.12.0.0" clr-version="4.0.30319.42000" os-version="Microsoft Windows NT 10.0.17134.0" platform="Win32NT" cwd="F:\src\BenedictionGame\testruns\latest" machine-name="SPENCER-VR" user="Oculus Rift" user-domain="SPENCER-VR" culture="en-US" uiculture="en-US" os-architecture="x64" />
    <settings>
      <setting name="DisposeRunners" value="True" />
      <setting name="WorkDirectory" value="F:\src\BenedictionGame\testruns\latest" />
      <setting name="ImageRuntimeVersion" value="4.0.30319" />
      <setting name="ImageTargetFrameworkName" value=".NETFramework,Version=v4.7.1" />
      <setting name="ImageRequiresX86" value="False" />
      <setting name="ImageRequiresDefaultAppDomainAssemblyResolver" value="False" />
      <setting name="NumberOfTestWorkers" value="12" />
    </settings>
    <properties>
      <property name="_PID" value="16864" />
      <property name="_APPDOMAIN" value="domain-" />
    </properties>
    <test-suite type="SetUpFixture" id="0-1000" name="[default namespace]" fullname="Testing_Specflow_NUnitAssemblyHooks" classname="Testing_Specflow_NUnitAssemblyHooks" runstate="Runnable" testcasecount="118" result="Passed" start-time="2020-02-08 19:21:42Z" end-time="2020-02-08 19:21:45Z" duration="2.845743" total="118" passed="115" failed="0" warnings="0" inconclusive="3" skipped="0" asserts="1106">
      <output><![CDATA[-> Loading plugin F:\src\BenedictionGame\src\Testing\Specflow\bin\Debug\TechTalk.SpecFlow.NUnit.SpecFlowPlugin.dll
-> Using default config
]]></output>
      <test-suite type="TestSuite" id="0-1131" name="Testing" fullname="Testing" runstate="Runnable" testcasecount="118" result="Passed" start-time="2020-02-08 19:21:42Z" end-time="2020-02-08 19:21:45Z" duration="2.235128" total="118" passed="115" failed="0" warnings="0" inconclusive="3" skipped="0" asserts="1106">
        <test-suite type="TestSuite" id="0-1132" name="Specflow" fullname="Testing.Specflow" runstate="Runnable" testcasecount="118" result="Passed" start-time="2020-02-08 19:21:42Z" end-time="2020-02-08 19:21:45Z" duration="2.235106" total="118" passed="115" failed="0" warnings="0" inconclusive="3" skipped="0" asserts="1106">
          <test-suite type="TestSuite" id="0-1133" name="Features" fullname="Testing.Specflow.Features" runstate="Runnable" testcasecount="118" result="Passed" start-time="2020-02-08 19:21:42Z" end-time="2020-02-08 19:21:45Z" duration="2.235099" total="118" passed="115" failed="0" warnings="0" inconclusive="3" skipped="0" asserts="1106">
            <test-suite type="TestSuite" id="0-1135" name="ExampleGames" fullname="Testing.Specflow.Features.ExampleGames" runstate="Runnable" testcasecount="1" result="Passed" start-time="2020-02-08 19:21:42Z" end-time="2020-02-08 19:21:43Z" duration="0.315196" total="1" passed="1" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="261">
              <test-suite type="TestFixture" id="0-1128" name="AlekSamplesFeature" fullname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature" classname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature" runstate="Runnable" testcasecount="1" result="Passed" start-time="2020-02-08 19:21:42Z" end-time="2020-02-08 19:21:43Z" duration="0.314177" total="1" passed="1" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="261">
                <properties>
                  <property name="Description" value="Alek Samples" />
                  <property name="Category" value="scenario-image-only" />
                </properties>
                <test-case id="0-1129" name="AlekSampleGame1" fullname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature.AlekSampleGame1" methodname="AlekSampleGame1" classname="Testing.Specflow.Features.ExampleGames.AlekSamplesFeature" runstate="Runnable" seed="1637046185" result="Passed" start-time="2020-02-08 19:21:42Z" end-time="2020-02-08 19:21:43Z" duration="0.252484" asserts="261">
                  <properties>
                    <property name="Description" value="Alek Sample Game 1" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the following moves are performed:
  --- table step argument ---
  | RedAction1 | RedAction2 | BlueAction1 | BlueAction2 |
  | e3e4       | @e3        | f8+f7       | @f8         |
  | d1+d2      | @d1        | d7d6        | @d7         |
  | f1+f2      | @f1        | f7f5        | @f7         |
  | f2f4       | f4-1-f5    | d7+d6       | d6b4        |
  | d2f3       | @f2        | b4b2        | Bc2         |
  | f3h3       | f1+f2      | b2i5        | e9+f8       |
  | h3h5       | h5-1-i5    | @e9         | @d7         |
  | f4g4       | f2f4       | f8h6        | h6-1-i5     |
  | e3+e4      | h5i5       | h6i5        | @f8         |
  | f4d5       | e4e5       | e8+e9       | Bc7         |
  | e1+e2      | e2e4       | f7+e7       | e7e5        |
  | e4e5       | d5e6       | Be7         | @f7         |
  | e5c5       | Ba5        | d8+d7       | @d8         |
  | e6c6       | c6-1-d7    | d8d7        | @d8         |
  | c5b4       | c6d7       |             |             |
Accepted: e3e4
Accepted: @e3
Accepted: f8+f7
Accepted: @f8
Accepted: d1+d2
Accepted: @d1
Accepted: d7d6
Accepted: @d7
Accepted: f1+f2
Accepted: @f1
Accepted: f7f5
Accepted: @f7
Accepted: f2f4
Accepted: f4-1-f5
Accepted: d7+d6
Accepted: d6b4
Accepted: d2f3
Accepted: @f2
Accepted: b4b2
Accepted: Bc2
Accepted: f3h3
Accepted: f1+f2
Accepted: b2i5
Accepted: e9+f8
Accepted: h3h5
Accepted: h5-1-i5
Accepted: @e9
Accepted: @d7
Accepted: f4g4
Accepted: f2f4
Accepted: f8h6
Accepted: h6-1-i5
Accepted: e3+e4
Accepted: h5i5
Accepted: h6i5
Accepted: @f8
Accepted: f4d5
Accepted: e4e5
Accepted: e8+e9
Accepted: Bc7
Accepted: e1+e2
Accepted: e2e4
Accepted: f7+e7
Accepted: e7e5
Accepted: e4e5
Accepted: d5e6
Accepted: Be7
Accepted: @f7
Accepted: e5c5
Accepted: Ba5
Accepted: d8+d7
Accepted: @d8
Accepted: e6c6
Accepted: c6-1-d7
Accepted: d8d7
Accepted: @d8
Accepted: c5b4
Accepted: c6d7
-> done: ActionSteps.WhenTheFollowingMoves(<table>) (0.1s)
Then the following locations match:
  --- table step argument ---
  | Location | Contents | Size | Type   |
  | A5       | Block    |      |        |
  | C7       | Block    |      |        |
  | C2       | Block    |      |        |
  | E7       | Block    |      |        |
  | D1       | Red      | 1    | Normal |
  | B4       | Red      | 2    | King   |
  | D7       | Red      | 1    | Cursed |
  | F5       | Red      | 1    | Cursed |
  | G4       | Red      | 1    | Cursed |
  | D8       | Blue     | 1    | Normal |
  | E9       | Blue     | 2    | King   |
  | F7       | Blue     | 1    | Normal |
  | F8       | Blue     | 1    | Normal |
  | I5       | Blue     | 1    | Cursed |
A5 OK
C7 OK
C2 OK
E7 OK
D1 OK
B4 OK
D7 OK
F5 OK
G4 OK
D8 OK
E9 OK
F7 OK
F8 OK
I5 OK
-> done: ValidationSteps.ThenTheFollowingLocationsMatch(<table>) (0.0s)
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/fa0292c9-9df4-c4b7-986e-45d432ea12e9.png?raw=true)
]]></output>
                </test-case>
              </test-suite>
            </test-suite>
            <test-suite type="TestSuite" id="0-1134" name="GameRules" fullname="Testing.Specflow.Features.GameRules" runstate="Runnable" testcasecount="117" result="Passed" start-time="2020-02-08 19:21:42Z" end-time="2020-02-08 19:21:45Z" duration="2.235087" total="117" passed="114" failed="0" warnings="0" inconclusive="3" skipped="0" asserts="845">
              <test-suite type="TestFixture" id="0-1001" name="BlockRulesFeature" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" testcasecount="5" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.056085" total="5" passed="5" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="91">
                <properties>
                  <property name="Description" value="Block Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1002" name="BlockHappyPath" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.BlockHappyPath" methodname="BlockHappyPath" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="303532072" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.026398" asserts="5">
                  <properties>
                    <property name="Description" value="Block Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player blockades A1
Accepted: Ba1
-> done: ActionSteps.WhenIBlockade(Red, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has blocks matching: A1
Successfully validated 1 block.
-> done: ValidationSteps.ThenTheBoardHasBlocksMatching("A1") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1003" name="BlockMaximum" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.BlockMaximum" methodname="BlockMaximum" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="418654475" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.021674" asserts="65">
                  <properties>
                    <property name="Description" value="Block Maximum" />
                    <property name="Category" value="scenario-image-only" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When the following moves are performed:
  --- table step argument ---
  | RedAction1 | RedAction2 | BlueAction1 | BlueAction2 |
  | Be9        | Bb6        | Bd7         | Bf7         |
  | Bh6        | Ba4        | Bc5         | Be6         |
  | Bg5        | Bi4        | Bb3         | Bd4         |
  | Bf4        | Bh3        | Ba1         | Bc2         |
  | Be3        | Bg2        | Bi1         | Bd1         |
  | Bf1        |            |             |             |
Accepted: Be9
Accepted: Bb6
Accepted: Bd7
Accepted: Bf7
Accepted: Bh6
Accepted: Ba4
Accepted: Bc5
Accepted: Be6
Accepted: Bg5
Accepted: Bi4
Accepted: Bb3
Accepted: Bd4
Accepted: Bf4
Accepted: Bh3
Accepted: Ba1
Accepted: Bc2
Accepted: Be3
Accepted: Bg2
Accepted: Bi1
Accepted: Bd1
Accepted: Bf1
-> done: ActionSteps.WhenTheFollowingMoves(<table>) (0.0s)
Then the board has blocks matching: A14B36C25D147E369F147G25H36I14
Successfully validated 21 blocks.
-> done: ValidationSteps.ThenTheBoardHasBlocksMatching("A14B36C25D147E369...") (0.0s)
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/20875bc2-1002-a4e0-45d9-f2eb9dcc1296.png?raw=true)
]]></output>
                </test-case>
                <test-case id="0-1005" name="CannotBlockAdjacentAnotherBlock" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.CannotBlockAdjacentAnotherBlock" methodname="CannotBlockAdjacentAnotherBlock" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="2111646116" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.004767" asserts="7">
                  <properties>
                    <property name="Description" value="Cannot Block Adjacent Another Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When the red player blocks e3
Accepted: Be3
-> done: ActionSteps.WhenIBlockade(Red, E3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player blocks e4
Rejected: Be4: Cannot Block Adjacent Existing Block E3
-> done: ActionSteps.WhenIBlockade(Red, E4) (0.0s)
Then the action fails
Failed with: Cannot Block Adjacent Existing Block E3
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
And the board has blocks matching: E3
Successfully validated 1 block.
-> done: ValidationSteps.ThenTheBoardHasBlocksMatching("E3") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1004" name="CannotBlockHomeSpace" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.CannotBlockHomeSpace" methodname="CannotBlockHomeSpace" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="1605706922" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001305" asserts="8">
                  <properties>
                    <property name="Description" value="Cannot Block Home Space" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When the red player blocks e2
Rejected: Be2: Cannot Block Red Home at Location E2
-> done: ActionSteps.WhenIBlockade(Red, E2) (0.0s)
Then the action fails
Failed with: Cannot Block Red Home at Location E2
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player blocks e8
Rejected: Be8: Cannot Block Blue Home at Location E8
-> done: ActionSteps.WhenIBlockade(Red, E8) (0.0s)
Then the action fails
Failed with: Cannot Block Blue Home at Location E8
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1006" name="CannotBlockOccupiedSpace" fullname="Testing.Specflow.Features.GameRules.BlockRulesFeature.CannotBlockOccupiedSpace" methodname="CannotBlockOccupiedSpace" classname="Testing.Specflow.Features.GameRules.BlockRulesFeature" runstate="Runnable" seed="1328660659" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000993" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Block Occupied Space" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player blockades e3
Rejected: Be3: Location E3 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E3) (0.0s)
Then the action fails
Failed with: Location E3 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1007" name="BridgeRulesFeature" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" testcasecount="7" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.180490" total="7" passed="7" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="25">
                <properties>
                  <property name="Description" value="Bridge Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1013" name="BridgeCannotBlessCursedPieces" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.BridgeCannotBlessCursedPieces" methodname="BridgeCannotBlessCursedPieces" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="2045380660" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.026382" asserts="3">
                  <properties>
                    <property name="Description" value="Bridge Cannot Bless Cursed Pieces" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                         |
  | Benediction v1: R-E2 B E8     |
  | R:D12E12k3F6++G1c+2cH2c3c5c6c |
  | B:E8k                         |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/814cb5e2-fc1a-36e5-5d1a-8c14a9e50781.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from f6 to h4
Accepted: f6-2-h4
-> done: ActionSteps.WhenISplit(Red, "2", F6, H4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3F6cG1c+2cH2c3c4b+5c6c
Successfully validated 13 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F6cG1c+2c...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1008" name="BridgeHappyPath" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.BridgeHappyPath" methodname="BridgeHappyPath" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="484431199" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.025610" asserts="2">
                  <properties>
                    <property name="Description" value="Bridge Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:C2D13E12k4F124G4H4I45   |
  | B:A12B3C4D578E68k9F68G6   |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/78ef14af-3123-d5a7-50c7-8f649cc50dcb.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at d1 to c1
Accepted: d1c1
-> done: ActionSteps.WhenIMove(Red, D1, C1) (0.0s)
Then the board has red pieces matching: C1b2bD3bE12k4bF124bG4bH4bI4b5b
Successfully validated 13 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "C1b2bD3bE12k4bF12...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1009" name="BridgeMaximum" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.BridgeMaximum" methodname="BridgeMaximum" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="1357684247" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.032938" asserts="5">
                  <properties>
                    <property name="Description" value="Bridge Maximum" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                                   |
  | Benediction v1: R-E2 B E8               |
  | R:A14B245C246D468E2k468kF2467G246H24I23 |
  | B:E7k                                   |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/d95525f1-17d2-eac0-1f5d-6cdb34d27096.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player drops a new piece at d2
Accepted: @d2
-> done: ActionSteps.WhenIDrop(Red, D2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
And the board has red pieces matching: A1b4bB2b4b5bC2b4b6bD2b4b6b8bE2kb4b6b8kbF2b4b6b7bG2b4b6bH2b4bI2b3b
Successfully validated 27 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1b4bB2b4b5bC2b4b...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1010" name="BridgeWithWrongColorCriticalPiece" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.BridgeWithWrongColorCriticalPiece" methodname="BridgeWithWrongColorCriticalPiece" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="140531299" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.024637" asserts="4">
                  <properties>
                    <property name="Description" value="Bridge With Wrong Color Critical Piece" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:D12E12k3F12G2H2356      |
  | B:E8kG4                   |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b3562125-3cee-c7e2-67c3-b4b411cfe6ec.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at g4 to h4
Accepted: g4h4
-> done: ActionSteps.WhenIMove(Blue, G4, H4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has blue pieces matching: E8kH4
Successfully validated 2 Blue pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Blue, "E8kH4") (0.0s)
And the board has red pieces matching: D12E12k3F12G2H2356
Successfully validated 12 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F12G2H2356") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1014" name="HomeDropCompletingBridgeWinsGame" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.HomeDropCompletingBridgeWinsGame" methodname="HomeDropCompletingBridgeWinsGame" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="1433400960" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.021604" asserts="5">
                  <properties>
                    <property name="Description" value="Home Drop Completing Bridge Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1kE1345F5G5H5I5        |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/5dbd8ef0-9411-39f4-eb9b-ddc996f39edf.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player drops a new piece at e2
Accepted: @e2
-> done: ActionSteps.WhenIDrop(Red, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: A1kE1b2kb3b4b5bF5bG5bH5bI5b
Successfully validated 10 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1kE1b2kb3b4b5bF5...") (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1011" name="SplitIntoBridgeAvoidsAllCursesIfSplitPiecesAdjacent" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.SplitIntoBridgeAvoidsAllCursesIfSplitPiecesAdjacent" methodname="SplitIntoBridgeAvoidsAllCursesIfSplitPiecesAdjacent" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="605669813" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.023836" asserts="3">
                  <properties>
                    <property name="Description" value="Split Into Bridge Avoids All Curses If Split Pieces Adjacent" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G25+H2356    |
  | B:E8k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/ff3696be-88c4-9dc3-f7b8-aed219f754b5.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from g5 to h4
Accepted: g5-1-h4
-> done: ActionSteps.WhenISplit(Red, "1", G5, H4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D1b2bE1b2kb3bF1b2bG2b5bH2b3b4b5b6b
Successfully validated 14 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D1b2bE1b2kb3bF1b2...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1012" name="SplitIntoBridgeAvoidsTargetCurseIfTargetPieceAdjacent" fullname="Testing.Specflow.Features.GameRules.BridgeRulesFeature.SplitIntoBridgeAvoidsTargetCurseIfTargetPieceAdjacent" methodname="SplitIntoBridgeAvoidsTargetCurseIfTargetPieceAdjacent" classname="Testing.Specflow.Features.GameRules.BridgeRulesFeature" runstate="Runnable" seed="1884260032" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.024862" asserts="3">
                  <properties>
                    <property name="Description" value="Split Into Bridge Avoids Target Curse If Target Piece Adjacent" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F126++G2H2356   |
  | B:E8k                     |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/739759a2-cf38-4707-eaad-df778518d406.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from f6 to h4
Accepted: f6-2-h4
-> done: ActionSteps.WhenISplit(Red, "2", F6, H4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D1b2bE1b2kb3bF1b2b6cG2bH2b3b4b+5b6b
Successfully validated 14 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D1b2bE1b2kb3bF1b2...") (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1015" name="DropRulesFeature" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" testcasecount="5" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.053656" total="5" passed="5" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="25">
                <properties>
                  <property name="Description" value="Drop Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1018" name="CannotDropOntoBlock" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.CannotDropOntoBlock" methodname="CannotDropOntoBlock" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="900459925" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.025383" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Drop Onto Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12kF12              |
  | B:D78E78k9F78             |
  | X:E3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/05727d7d-a822-e663-e593-85887fdd5e22.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player drops a new piece at e3
Rejected: @e3: Location E3 Not Empty
-> done: ActionSteps.WhenIDrop(Red, E3) (0.0s)
Then the action fails
Failed with: Location E3 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1019" name="CannotDropOntoOccupiedSpace" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.CannotDropOntoOccupiedSpace" methodname="CannotDropOntoOccupiedSpace" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="172388280" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.002735" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Drop Onto Occupied Space" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player drops a new piece at e3
Rejected: @e3: Location E3 Not Empty
-> done: ActionSteps.WhenIDrop(Red, E3) (0.0s)
Then the action fails
Failed with: Location E3 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1017" name="CannotDropOutsideZone" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.CannotDropOutsideZone" methodname="CannotDropOutsideZone" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="2098809401" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001296" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Drop Outside Zone" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player drops a new piece at e5
Rejected: @e5: Drop Must Be Adjacent Your Home At E2
-> done: ActionSteps.WhenIDrop(Red, E5) (0.0s)
Then the action fails
Failed with: Drop Must Be Adjacent Your Home At E2
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1016" name="DropHappyPath" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.DropHappyPath" methodname="DropHappyPath" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="753631377" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001722" asserts="6">
                  <properties>
                    <property name="Description" value="Drop Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player drops a new piece at e3
Accepted: @e3
-> done: ActionSteps.WhenIDrop(Red, E3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1020" name="HomeDropBecomesKing" fullname="Testing.Specflow.Features.GameRules.DropRulesFeature.HomeDropBecomesKing" methodname="HomeDropBecomesKing" classname="Testing.Specflow.Features.GameRules.DropRulesFeature" runstate="Runnable" seed="1906992712" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.021855" asserts="3">
                  <properties>
                    <property name="Description" value="Home Drop Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E13kF12              |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/e0431d0b-1adc-1d00-8381-6904a3edfbbc.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player drops a new piece at e2
Accepted: @e2
-> done: ActionSteps.WhenIDrop(Red, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3kF12
Successfully validated 7 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3kF12") (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1021" name="ExamplesFeature" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" testcasecount="22" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.027189" total="22" passed="22" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="238">
                <properties>
                  <property name="Description" value="Examples" />
                  <property name="Category" value="no-images" />
                </properties>
                <test-case id="0-1028" name="CannotBlockOwnKing" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.CannotBlockOwnKing" methodname="CannotBlockOwnKing" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1600146635" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.002674" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Block Own King" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
When red does Be2
Rejected: Be2: Cannot Block Red Home at Location E2
-> done: ActionSteps.WhenDoes(Red, "Be2") (0.0s)
Then the action fails
Failed with: Cannot Block Red Home at Location E2
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1022" name="LoadAPreviouslyCreatedBoard" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.LoadAPreviouslyCreatedBoard" methodname="LoadAPreviouslyCreatedBoard" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="372220310" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000816" asserts="2">
                  <properties>
                    <property name="Description" value="Load a Previously Created Board" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I have board WeirdSituation1
Loaded board WeirdSituation1.
-> done: SetupSteps.GivenIHaveNamedBoard("WeirdSituation1") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1024" name="LoadASavedBoard" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.LoadASavedBoard" methodname="LoadASavedBoard" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="152849208" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000959" asserts="0">
                  <properties>
                    <property name="Description" value="Load a Saved Board" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                       |
  | Benediction v1: R E2 B-E8   |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+ |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+ |
  | X:B5C2D4E6F3H6I1            |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1029" name="MergeSplitMergeDoesntCreatePieces" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.MergeSplitMergeDoesntCreatePieces" methodname="MergeSplitMergeDoesntCreatePieces" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="546799891" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001187" asserts="3">
                  <properties>
                    <property name="Description" value="Merge Split Merge Doesn't Create Pieces" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 onto e3
Accepted: f2+e3
-> done: ActionSteps.WhenIMerge(Red, F2, E3) (0.0s)
And the red player splits 1 piece from e3 onto d2
Accepted: e3-1-d2
-> done: ActionSteps.WhenISplit(Red, "1", E3, D2) (0.0s)
Then the board has red pieces matching: D12+E12k3F1
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12+E12k3F1") (0.0s)
]]></output>
                </test-case>
                <test-suite type="ParameterizedMethod" id="0-1044" name="NoneOfTheseAreValidBlockLocations" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" testcasecount="14" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.008715" total="14" passed="14" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="56">
                  <properties>
                    <property name="Description" value="None of These Are Valid Block Locations" />
                  </properties>
                  <test-case id="0-1030" name="NoneOfTheseAreValidBlockLocations(&quot;d1&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;d1&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1618594429" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001163" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades d1
Rejected: Bd1: Location D1 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, D1) (0.0s)
Then the action fails
Failed with: Location D1 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1031" name="NoneOfTheseAreValidBlockLocations(&quot;d2&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;d2&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="653988757" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000411" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades d2
Rejected: Bd2: Location D2 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, D2) (0.0s)
Then the action fails
Failed with: Location D2 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1032" name="NoneOfTheseAreValidBlockLocations(&quot;e1&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e1&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="888894960" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000404" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e1
Rejected: Be1: Location E1 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E1) (0.0s)
Then the action fails
Failed with: Location E1 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1033" name="NoneOfTheseAreValidBlockLocations(&quot;e2&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e2&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="927853507" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000398" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e2
Rejected: Be2: Location E2 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E2) (0.0s)
Then the action fails
Failed with: Location E2 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1034" name="NoneOfTheseAreValidBlockLocations(&quot;e3&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e3&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1379590259" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000367" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e3
Rejected: Be3: Location E3 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E3) (0.0s)
Then the action fails
Failed with: Location E3 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1035" name="NoneOfTheseAreValidBlockLocations(&quot;f1&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;f1&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1338853915" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000378" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades f1
Rejected: Bf1: Location F1 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, F1) (0.0s)
Then the action fails
Failed with: Location F1 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1036" name="NoneOfTheseAreValidBlockLocations(&quot;f2&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;f2&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1958154913" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000369" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades f2
Rejected: Bf2: Location F2 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, F2) (0.0s)
Then the action fails
Failed with: Location F2 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1037" name="NoneOfTheseAreValidBlockLocations(&quot;d7&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;d7&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1045485700" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000456" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades d7
Rejected: Bd7: Location D7 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, D7) (0.0s)
Then the action fails
Failed with: Location D7 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1038" name="NoneOfTheseAreValidBlockLocations(&quot;d8&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;d8&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1928117354" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000522" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades d8
Rejected: Bd8: Location D8 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, D8) (0.0s)
Then the action fails
Failed with: Location D8 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1039" name="NoneOfTheseAreValidBlockLocations(&quot;e7&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e7&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="2123739885" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000442" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e7
Rejected: Be7: Location E7 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E7) (0.0s)
Then the action fails
Failed with: Location E7 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1040" name="NoneOfTheseAreValidBlockLocations(&quot;e8&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e8&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="155833840" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000487" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e8
Rejected: Be8: Location E8 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E8) (0.0s)
Then the action fails
Failed with: Location E8 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1041" name="NoneOfTheseAreValidBlockLocations(&quot;e9&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;e9&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="116094409" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000625" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades e9
Rejected: Be9: Location E9 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, E9) (0.0s)
Then the action fails
Failed with: Location E9 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1042" name="NoneOfTheseAreValidBlockLocations(&quot;f7&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;f7&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1934885158" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.000539" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades f7
Rejected: Bf7: Location F7 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, F7) (0.0s)
Then the action fails
Failed with: Location F7 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                  <test-case id="0-1043" name="NoneOfTheseAreValidBlockLocations(&quot;f8&quot;,null)" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.NoneOfTheseAreValidBlockLocations(&quot;f8&quot;,null)" methodname="NoneOfTheseAreValidBlockLocations" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1460925399" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001794" asserts="4">
                    <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player blockades f8
Rejected: Bf8: Location F8 Not Empty
-> done: ActionSteps.WhenIBlockade(Red, F8) (0.0s)
Then the action fails
Failed with: Location F8 Not Empty
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                  </test-case>
                </test-suite>
                <test-case id="0-1025" name="PerformSomeMoves" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.PerformSomeMoves" methodname="PerformSomeMoves" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1076480565" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001914" asserts="6">
                  <properties>
                    <property name="Description" value="Perform Some Moves" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at e3 to e4
Accepted: e3e4
-> done: ActionSteps.WhenIMove(Red, E3, E4) (0.0s)
When the red player drops a new piece at e3
Accepted: @e3
-> done: ActionSteps.WhenIDrop(Red, E3) (0.0s)
When the blue player blockades c2
Accepted: Bc2
-> done: ActionSteps.WhenIBlockade(Blue, C2) (0.0s)
When the blue player merges the piece at f7 into e7
Accepted: f7+e7
-> done: ActionSteps.WhenIMerge(Blue, F7, E7) (0.0s)
When the red player merges the piece at e4 into e3
Accepted: e4+e3
-> done: ActionSteps.WhenIMerge(Red, E4, E3) (0.0s)
When the red player splits 1 piece from e3 onto d2
Accepted: e3-1-d2
-> done: ActionSteps.WhenISplit(Red, "1", E3, D2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1026" name="PerformSomeMoves_ShortNotation" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.PerformSomeMoves_ShortNotation" methodname="PerformSomeMoves_ShortNotation" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="1944781468" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001776" asserts="22">
                  <properties>
                    <property name="Description" value="Perform Some Moves - Short Notation" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When red does e3e4
Accepted: e3e4
-> done: ActionSteps.WhenDoes(Red, "e3e4") (0.0s)
When red does @e3
Accepted: @e3
-> done: ActionSteps.WhenDoes(Red, "@e3") (0.0s)
When blue does Bc2
Accepted: Bc2
-> done: ActionSteps.WhenDoes(Blue, "Bc2") (0.0s)
When blue does f7+e7
Accepted: f7+e7
-> done: ActionSteps.WhenDoes(Blue, "f7+e7") (0.0s)
When red does e4+e3
Accepted: e4+e3
-> done: ActionSteps.WhenDoes(Red, "e4+e3") (0.0s)
When red does e3-1-d2
Accepted: e3-1-d2
-> done: ActionSteps.WhenDoes(Red, "e3-1-d2") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1027" name="PerformSomeMoves_TableNotation" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.PerformSomeMoves_TableNotation" methodname="PerformSomeMoves_TableNotation" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="775652777" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.006339" asserts="141">
                  <properties>
                    <property name="Description" value="Perform Some Moves - Table Notation" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the following moves are performed:
  --- table step argument ---
  | RedAction1 | RedAction2 | BlueAction1 | BlueAction2 |
  | f1+f2      | f2-1-g2    | e8+e9       | Bi3         |
  | e3+d2      | Bb5        | f7+f8       | f8f7        |
  | d2c1       | e1f1       | Ba2         | f7-1-g7     |
  | e2e3       | d1e1       | Bf8         | f7g6        |
  | Bg1        | Bb1        | Bd4         | d7+e7       |
  | f1+e1      | f2e2       | @d7         | d7+d8       |
  | @f2        | f2+e2      | @d7         | @e8         |
  | @f2        | e3+f2      | e8+d7       | @e8         |
  | @d1        | @e3        | @f7         | f7+e8       |
  | @f1        | @d2        | @f7         | Bd6         |
Accepted: f1+f2
Accepted: f2-1-g2
Accepted: e8+e9
Accepted: Bi3
Accepted: e3+d2
Accepted: Bb5
Accepted: f7+f8
Accepted: f8f7
Accepted: d2c1
Accepted: e1f1
Accepted: Ba2
Accepted: f7-1-g7
Accepted: e2e3
Accepted: d1e1
Accepted: Bf8
Accepted: f7g6
Accepted: Bg1
Accepted: Bb1
Accepted: Bd4
Accepted: d7+e7
Accepted: f1+e1
Accepted: f2e2
Accepted: @d7
Accepted: d7+d8
Accepted: @f2
Accepted: f2+e2
Accepted: @d7
Accepted: @e8
Accepted: @f2
Accepted: e3+f2
Accepted: e8+d7
Accepted: @e8
Accepted: @d1
Accepted: @e3
Accepted: @f7
Accepted: f7+e8
Accepted: @f1
Accepted: @d2
Accepted: @f7
Accepted: Bd6
-> done: ActionSteps.WhenTheFollowingMoves(<table>) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1023" name="StartFromAnEmptyBoard" fullname="Testing.Specflow.Features.GameRules.ExamplesFeature.StartFromAnEmptyBoard" methodname="StartFromAnEmptyBoard" classname="Testing.Specflow.Features.GameRules.ExamplesFeature" runstate="Runnable" seed="206367714" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001999" asserts="2">
                  <properties>
                    <property name="Description" value="Start From an Empty Board" />
                  </properties>
                  <output><![CDATA[Given I define board WeirdSituation1 as:
  --- table step argument ---
  | Any header here - the name doesn't matter |
  | Benediction v1: R E2 B-E8                 |
  | R:D1+2+E1k+2k+3k+F1k2G1k+2+               |
  | B:D6k+7k+8E7+8k+9k+F78k+H5+               |
  | X:B5C2D4E6F3H6I1                          |
-> done: SetupSteps.GivenIDefine("WeirdSituation1", <table>) (0.0s)
Given I have an empty E2 E8 board
Loaded empty game board with Red Home at E2 and Blue Home at E8
-> done: SetupSteps.GivenIHaveAnEmptyBoard(E2, E8) (0.0s)
And I add this red piece: E3k+
-> done: SetupSteps.GivenIAddPieces(Red, "E3k+") (0.0s)
And I add these blue pieces: D45+E56k7F5++++6+b+++7+++++
-> done: SetupSteps.GivenIAddPieces(Blue, "D45+E56k7F5++++6+...") (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1045" name="MergeRulesFeature" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" testcasecount="14" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.292294" total="14" passed="14" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="82">
                <properties>
                  <property name="Description" value="Merge Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1059" name="CannotMergeAboveStackSizeFifteen" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeAboveStackSizeFifteen" methodname="CannotMergeAboveStackSizeFifteen" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="635569671" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.037261" asserts="20">
                  <properties>
                    <property name="Description" value="Cannot Merge Above Stack Size Fifteen" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                                                       |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b27181cc-4da3-da5d-d8d1-f617dc82b43a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e3
Rejected: f2+e3: Merging Stacks Size 8 and 8 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, F2, E3) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 8 and 8 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece at d2 into e2
Rejected: d2+e2: Merging Stacks Size 15 and 1 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, D2, E2) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 15 and 1 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece at d2 into e3
Rejected: d2+e3: Merging Stacks Size 15 and 8 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, D2, E3) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 15 and 8 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece at d2 into d1
Rejected: d2+d1: Merging Stacks Size 15 and 14 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, D2, D1) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 15 and 14 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece at d1 into e1
Rejected: d1+e1: Merging Stacks Size 14 and 2 Exceeds 15 Max
-> done: ActionSteps.WhenIMerge(Red, D1, E1) (0.0s)
Then the action fails
Failed with: Merging Stacks Size 14 and 2 Exceeds 15 Max
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1053" name="CannotMergeCursedAndCursed" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeCursedAndCursed" methodname="CannotMergeCursedAndCursed" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1054104921" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.025593" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Merge Cursed and Cursed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F1c2c           |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b53c4abd-3ff0-0046-c86c-c16cf82ad695.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into f1
Rejected: f2+f1: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1057" name="CannotMergeCursedAndKing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeCursedAndKing" methodname="CannotMergeCursedAndKing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="587049489" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.021809" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Merge Cursed and King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12c            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/7702661f-3c93-feed-fda8-45ce88ada492.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Rejected: f2+e2: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1052" name="CannotMergeCursedAndNormal" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeCursedAndNormal" methodname="CannotMergeCursedAndNormal" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="275263981" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.022669" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Merge Cursed and Normal" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F1c2            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/9f8ddd85-d582-f495-2d03-eb7ea80e8865.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into f1
Rejected: f2+f1: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1058" name="CannotMergeKingAndKing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.CannotMergeKingAndKing" methodname="CannotMergeKingAndKing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1379352813" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.020721" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Merge King and King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12k            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/3c4d56ad-3a5b-a725-df1c-8a3b2b8fc8d3.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Rejected: f2+e2: Kings Cannot Merge With Kings
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action fails
Failed with: Kings Cannot Merge With Kings
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1049" name="MergeAboveSizeTwoRequiresBlessing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeAboveSizeTwoRequiresBlessing" methodname="MergeAboveSizeTwoRequiresBlessing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1283890990" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.030302" asserts="12">
                  <properties>
                    <property name="Description" value="Merge Above Size Two Requires Blessing" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player merges the piece at f2 into f1
Rejected: f2+f1: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
Given I add these red pieces: F2+b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/53797757-f294-7693-6a53-d191f19b39cf.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "F2+b") (0.0s)
When the red player merges the piece at f2 into f1
Accepted: f2+f1
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12kF1++
Successfully validated 5 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12kF1++") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1056" name="MergeBlessedAndKing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeBlessedAndKing" methodname="MergeBlessedAndKing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1909039765" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.024979" asserts="4">
                  <properties>
                    <property name="Description" value="Merge Blessed and King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12b+           |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/806c4628-6872-0f9b-9ff1-5461ac27050a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Accepted: f2+e2
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king on e2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "three", E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1051" name="MergeCursedAndBlessed" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeCursedAndBlessed" methodname="MergeCursedAndBlessed" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="666142173" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.028328" asserts="3">
                  <properties>
                    <property name="Description" value="Merge Cursed and Blessed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F1c2b           |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4a9df996-ea1d-7e72-f373-673118de7300.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into f1
Accepted: f2+f1
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3F1+
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F1+") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1046" name="MergeHappyPath" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeHappyPath" methodname="MergeHappyPath" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="411109575" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001184" asserts="4">
                  <properties>
                    <property name="Description" value="Merge Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1047" name="MergeMaximum" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeMaximum" methodname="MergeMaximum" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="845347035" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.024937" asserts="3">
                  <properties>
                    <property name="Description" value="Merge Maximum" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                       |
  | Benediction v1: R-E2 B E8   |
  | R:D12E12k3++++++F12b+++++++ |
  | B:D78E78k9F78               |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/c0f25e85-cb2b-1fee-037a-4cfeaa26f6ca.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 onto e3
Accepted: f2+e3
-> done: ActionSteps.WhenIMerge(Red, F2, E3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3++++++++++++++F1
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3+++++++++...") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1050" name="MergeNormalAndBlessed" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeNormalAndBlessed" methodname="MergeNormalAndBlessed" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1124841203" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.025184" asserts="3">
                  <properties>
                    <property name="Description" value="Merge Normal and Blessed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12b            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/d4f4fc68-d7e7-8034-7a3b-74193eb59e42.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into f1
Accepted: f2+f1
-> done: ActionSteps.WhenIMerge(Red, F2, F1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3F1+
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F1+") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1054" name="MergeNormalAndKing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeNormalAndKing" methodname="MergeNormalAndKing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1926750455" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001472" asserts="4">
                  <properties>
                    <property name="Description" value="Merge Normal and King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Accepted: f2+e2
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack king on e2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "two", E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1055" name="MergeNormalAndKingAboveStackSizeTwoRequiresBlessing" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeNormalAndKingAboveStackSizeTwoRequiresBlessing" methodname="MergeNormalAndKingAboveStackSizeTwoRequiresBlessing" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1879489681" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.025074" asserts="9">
                  <properties>
                    <property name="Description" value="Merge Normal and King Above Stack Size Two Requires Blessing" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12+            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/958e301d-86b0-3c1f-6675-e2644b1c99c2.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f2 into e2
Rejected: f2+e2: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
Given I add this red piece: F2b+
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/806c4628-6872-0f9b-9ff1-5461ac27050a.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "F2b+") (0.0s)
When the red player merges the piece at f2 into e2
Accepted: f2+e2
-> done: ActionSteps.WhenIMerge(Red, F2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack king on e2
-> done: ValidationSteps.ThenThereShouldBeKing(Red, "three", E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1048" name="MergeNormalAndNormal" fullname="Testing.Specflow.Features.GameRules.MergeRulesFeature.MergeNormalAndNormal" methodname="MergeNormalAndNormal" classname="Testing.Specflow.Features.GameRules.MergeRulesFeature" runstate="Runnable" seed="1633955090" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.002025" asserts="4">
                  <properties>
                    <property name="Description" value="Merge Normal and Normal" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1060" name="MovementRulesFeature" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" testcasecount="9" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.111445" total="9" passed="9" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="97">
                <properties>
                  <property name="Description" value="Movement Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1063" name="BlueCannotMoveThroughBlueWall" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.BlueCannotMoveThroughBlueWall" methodname="BlueCannotMoveThroughBlueWall" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="680854884" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.009519" asserts="31">
                  <properties>
                    <property name="Description" value="Blue Cannot Move Through Blue Wall" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
And the current turn is BlueAction1
Board flags set to: BlueAction1
-> done: CommonSteps.GivenTheCurrentTurnIsRed(BlueAction1) (0.0s)
When the blue player moves the piece at e9 to e1
Rejected: e9e1: Stack Size 1 Piece At E9 Cannot Reach E1 (but can reach: E8)
-> done: ActionSteps.WhenIMove(Blue, E9, E1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E9 Cannot Reach E1 (but can reach: E8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at e9 to e5
Rejected: e9e5: Stack Size 1 Piece At E9 Cannot Reach E5 (but can reach: E8)
-> done: ActionSteps.WhenIMove(Blue, E9, E5) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E9 Cannot Reach E5 (but can reach: E8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at e9 to a5
Rejected: e9a5: Stack Size 1 Piece At E9 Cannot Reach A5 (but can reach: D8)
-> done: ActionSteps.WhenIMove(Blue, E9, A5) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E9 Cannot Reach A5 (but can reach: D8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at f8 to f1
Rejected: f8f1: Stack Size 1 Piece At F8 Cannot Reach F1 (but can reach: F7)
-> done: ActionSteps.WhenIMove(Blue, F8, F1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F8 Cannot Reach F1 (but can reach: F7)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at f8 to a4
Rejected: f8a4: Stack Size 1 Piece At F8 Cannot Reach A4 (but can reach: E8)
-> done: ActionSteps.WhenIMove(Blue, F8, A4) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F8 Cannot Reach A4 (but can reach: E8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at d8 to d1
Rejected: d8d1: Stack Size 1 Piece At D8 Cannot Reach D1 (but can reach: D7)
-> done: ActionSteps.WhenIMove(Blue, D8, D1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D8 Cannot Reach D1 (but can reach: D7)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the blue player moves the piece at d8 to i4
Rejected: d8i4: Stack Size 1 Piece At D8 Cannot Reach I4 (but can reach: E8)
-> done: ActionSteps.WhenIMove(Blue, D8, I4) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D8 Cannot Reach I4 (but can reach: E8)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1065" name="CanCaptureEnemyPiece" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CanCaptureEnemyPiece" methodname="CanCaptureEnemyPiece" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="916600200" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.025970" asserts="4">
                  <properties>
                    <property name="Description" value="Can Capture Enemy Piece" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F24+            |
  | B:D5+7E78k9F78            |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/d41338c3-5a07-b52e-0a73-bb854689c0ad.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at f4 two points to the northwest
Accepted: f4d5
-> done: ActionSteps.WhenIMovePointsDirection(Red, F4, "two", "northwest") (0.0s)
Then there should be a red two-stack on d5
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", D5) (0.0s)
And there should not be any blue pieces on d5
-> done: ValidationSteps.ThenThereShouldNotBeAny(Blue, D5) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1066" name="CannotCaptureOwnPiece" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CannotCaptureOwnPiece" methodname="CannotCaptureOwnPiece" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="478192126" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001185" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Capture Own Piece" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F24+            |
  | B:D5+7E78k9F78            |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/d41338c3-5a07-b52e-0a73-bb854689c0ad.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at f4 two points to the south
Rejected: f4f2: Destination F2 Is Your Own Piece and Cannot Be Moved Onto By Red
-> done: ActionSteps.WhenIMovePointsDirection(Red, F4, "two", "south") (0.0s)
Then the action fails
Failed with: Destination F2 Is Your Own Piece and Cannot Be Moved Onto By Red
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1064" name="CannotDepartEdgeOfBoard" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CannotDepartEdgeOfBoard" methodname="CannotDepartEdgeOfBoard" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="694798394" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.022948" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Depart Edge Of Board" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3H2+             |
  | B:B5+E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/8fbbd754-a763-04be-d790-14795642a78a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at h2 two points to the northeast
Unable to reach point 2 northeast from I2 (starting from H2)
-> done: ActionSteps.WhenIMovePointsDirection(Red, H2, "two", "northeast") (0.0s)
Then the action fails
Failed with: Unable to reach point 2 northeast from I2 (starting from H2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1067" name="CannotMoveOntoBlock" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CannotMoveOntoBlock" methodname="CannotMoveOntoBlock" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="1314060955" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.023173" asserts="9">
                  <properties>
                    <property name="Description" value="Cannot Move Onto Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F24+            |
  | B:D5+7E78k9F78            |
  | X:E5G3                    |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b1dbf9f7-46b7-4600-43f7-89f3ead81c5e.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at f4 to e5
Rejected: f4e5: Destination E5 Contains a Block, Which Cannot Be Moved Onto
-> done: ActionSteps.WhenIMove(Red, F4, E5) (0.0s)
Then the action fails
Failed with: Destination E5 Contains a Block, Which Cannot Be Moved Onto
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
Given the current turn is BlueAction1
Board flags set to: BlueAction1
-> done: CommonSteps.GivenTheCurrentTurnIsRed(BlueAction1) (0.0s)
When the blue player moves the piece at d5 to e5
Rejected: d5e5: Destination E5 Contains a Block, Which Cannot Be Moved Onto
-> done: ActionSteps.WhenIMove(Blue, D5, E5) (0.0s)
Then the action fails
Failed with: Destination E5 Contains a Block, Which Cannot Be Moved Onto
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1068" name="CannotMoveOverBlock" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.CannotMoveOverBlock" methodname="CannotMoveOverBlock" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="934446771" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001395" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Move Over Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F24+            |
  | B:D5+7E78k9F78            |
  | X:E5G3                    |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b1dbf9f7-46b7-4600-43f7-89f3ead81c5e.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at f4 two points to the northwest
Rejected: f4d5: Stack Size 2 Piece At F4 Cannot Reach D5 (but can reach: )
-> done: ActionSteps.WhenIMovePointsDirection(Red, F4, "two", "northwest") (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At F4 Cannot Reach D5 (but can reach: )
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1069" name="MoveThroughWallIsAssumedIfPossible" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.MoveThroughWallIsAssumedIfPossible" methodname="MoveThroughWallIsAssumedIfPossible" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="2097387260" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.023619" asserts="3">
                  <properties>
                    <property name="Description" value="Move Through Wall Is Assumed If Possible" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B=E8 |
  | R:D12E12k3H4+++           |
  | B:B3+++D8E8k9F78          |
  | X:E5F6G3                  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/ede23154-af5e-5f21-ec9e-aef50f0f5630.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at b3 to b5
Accepted: b3b5
-> done: ActionSteps.WhenIMove(Blue, B3, B5) (0.0s)
Then there should be a blue four-stack with a blessing on b5
-> done: ValidationSteps.ThenThereShouldBeBlessed(Blue, "four", B5) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1062" name="RedCannotMoveThroughRedWall" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.RedCannotMoveThroughRedWall" methodname="RedCannotMoveThroughRedWall" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="1949973898" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001762" asserts="30">
                  <properties>
                    <property name="Description" value="Red Cannot Move Through Red Wall" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player moves the piece at e1 to e9
Rejected: e1e9: Stack Size 1 Piece At E1 Cannot Reach E9 (but can reach: E2)
-> done: ActionSteps.WhenIMove(Red, E1, E9) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E1 Cannot Reach E9 (but can reach: E2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at e1 to i1
Rejected: e1i1: Stack Size 1 Piece At E1 Cannot Reach I1 (but can reach: F1)
-> done: ActionSteps.WhenIMove(Red, E1, I1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E1 Cannot Reach I1 (but can reach: F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at e1 to a1
Rejected: e1a1: Stack Size 1 Piece At E1 Cannot Reach A1 (but can reach: D1)
-> done: ActionSteps.WhenIMove(Red, E1, A1) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E1 Cannot Reach A1 (but can reach: D1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at f1 to f8
Rejected: f1f8: Stack Size 1 Piece At F1 Cannot Reach F8 (but can reach: F2)
-> done: ActionSteps.WhenIMove(Red, F1, F8) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F1 Cannot Reach F8 (but can reach: F2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at f1 to a2
Rejected: f1a2: Stack Size 1 Piece At F1 Cannot Reach A2 (but can reach: E2)
-> done: ActionSteps.WhenIMove(Red, F1, A2) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F1 Cannot Reach A2 (but can reach: E2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at d1 to i2
Rejected: d1i2: Stack Size 1 Piece At D1 Cannot Reach I2 (but can reach: E2)
-> done: ActionSteps.WhenIMove(Red, D1, I2) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D1 Cannot Reach I2 (but can reach: E2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player moves the piece at d1 to d8
Rejected: d1d8: Stack Size 1 Piece At D1 Cannot Reach D8 (but can reach: D2)
-> done: ActionSteps.WhenIMove(Red, D1, D8) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D1 Cannot Reach D8 (but can reach: D2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1061" name="RepeatMovesNotAllowed" fullname="Testing.Specflow.Features.GameRules.MovementRulesFeature.RepeatMovesNotAllowed" methodname="RepeatMovesNotAllowed" classname="Testing.Specflow.Features.GameRules.MovementRulesFeature" runstate="Runnable" seed="251960794" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001159" asserts="8">
                  <properties>
                    <property name="Description" value="Repeat Moves Not Allowed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player moves the piece at e3 to e4
Accepted: e3e4
-> done: ActionSteps.WhenIMove(Red, E3, E4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player moves the piece at e4 to e5
Rejected: e4e5: Piece at E4 Has Already Moved This Turn
-> done: ActionSteps.WhenIMove(Red, E4, E5) (0.0s)
Then the action fails
Failed with: Piece at E4 Has Already Moved This Turn
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1070" name="SplitRulesFeature" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" testcasecount="18" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:44Z" duration="0.286513" total="18" passed="18" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="128">
                <properties>
                  <property name="Description" value="Split Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1085" name="BlessedStackLosesBlessingUponSplit_Merge" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.BlessedStackLosesBlessingUponSplit_Merge" methodname="BlessedStackLosesBlessingUponSplit_Merge" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="114824011" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.024866" asserts="6">
                  <properties>
                    <property name="Description" value="Blessed Stack Loses Blessing Upon Split-Merge" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3b+4F12          |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/90f1bf85-451b-8170-2c3d-7e90f7a0b854.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from e3 onto e4
Accepted: e3-1-e4
-> done: ActionSteps.WhenISplit(Red, "1", E3, E4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red two-stack on e4
-> done: ValidationSteps.ThenThereShouldBe(Red, "two", E4) (0.0s)
And there should be a red blessed one-stack on e3
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "one", E3) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1087" name="CannotSplit_MergeBlessedStackOntoKingOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeBlessedStackOntoKingOverStackSizeTwo" methodname="CannotSplit_MergeBlessedStackOntoKingOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1272163492" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.021496" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Blessed Stack Onto King Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5kF12         |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/e7694483-1fbe-7f94-5cc0-ffa5a5a36390.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1086" name="CannotSplit_MergeBlessedStackOntoRegularPieceOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeBlessedStackOntoRegularPieceOverStackSizeTwo" methodname="CannotSplit_MergeBlessedStackOntoRegularPieceOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="518225932" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.024102" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Blessed Stack Onto Regular Piece Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5F12          |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/97f9baab-af54-0698-1fbb-9749bf638fb2.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1081" name="CannotSplit_MergeOntoCursedPiece" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeOntoCursedPiece" methodname="CannotSplit_MergeOntoCursedPiece" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1412182184" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.026778" asserts="6">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Onto Cursed Piece" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3cF12            |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/da04bbbe-3ff9-839a-1207-25b2625b9b93.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at f1 into f2
Accepted: f1+f2
-> done: ActionSteps.WhenIMerge(Red, F1, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player splits 1 piece from f2 onto e3
Rejected: f2-1-e3: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", F2, E3) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1084" name="CannotSplit_MergeOntoKingOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeOntoKingOverStackSizeTwo" methodname="CannotSplit_MergeOntoKingOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="610865630" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.001403" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Onto King Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5kF12         |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/e7694483-1fbe-7f94-5cc0-ffa5a5a36390.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1083" name="CannotSplit_MergeOntoRegularPieceOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeOntoRegularPieceOverStackSizeTwo" methodname="CannotSplit_MergeOntoRegularPieceOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1055104084" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.002164" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Onto Regular Piece Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5F12          |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/97f9baab-af54-0698-1fbb-9749bf638fb2.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Blessed Piece (From Passing Opponent Wall) Required On Either Piece to Merge Above Stack Size Two
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1082" name="CannotSplit_MergeOverBlock" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.CannotSplit_MergeOverBlock" methodname="CannotSplit_MergeOverBlock" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1394065524" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.030619" asserts="4">
                  <properties>
                    <property name="Description" value="Cannot Split-Merge Over Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5bF12         |
  | B:D78E78k9F78             |
  | X:E4                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/958ad4d6-8e2f-9ad0-14c7-fbbb8fa53814.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Rejected: e3-2-e5: Stack Size 2 Piece At E3 Cannot Reach E5 (but can reach: E2, E1)
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At E3 Cannot Reach E5 (but can reach: E2, E1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1079" name="Split_CaptureCannotMoveOverBlock" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_CaptureCannotMoveOverBlock" methodname="Split_CaptureCannotMoveOverBlock" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1756053669" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:43Z" duration="0.024049" asserts="4">
                  <properties>
                    <property name="Description" value="Split-Capture Cannot Move Over Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12+++          |
  | B:D78E78k9F478            |
  | X:F3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/0fdeee82-abf5-deb7-0300-f0e22b1e77e1.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from f2 onto f4
Rejected: f2-2-f4: Stack Size 2 Piece At F2 Cannot Reach F4 (but can reach: F1)
-> done: ActionSteps.WhenISplit(Red, "2", F2, F4) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At F2 Cannot Reach F4 (but can reach: F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1072" name="Split_CaptureHappyPath" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_CaptureHappyPath" methodname="Split_CaptureHappyPath" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1623940027" result="Passed" start-time="2020-02-08 19:21:43Z" end-time="2020-02-08 19:21:44Z" duration="0.020572" asserts="3">
                  <properties>
                    <property name="Description" value="Split-Capture Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:D12E12k6+F1             |
  | B:D78E78k9F5+             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/083b4731-de09-b68b-edca-be011f3f1734.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from e6 onto e7
Accepted: e6-1-e7
-> done: ActionSteps.WhenISplit(Red, "1", E6, E7) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k6c7cF1
Successfully validated 7 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k6c7cF1") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1088" name="Split_MergeBlessedStackOntoBlessedPieceOverStackSizeTwo" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeBlessedStackOntoBlessedPieceOverStackSizeTwo" methodname="Split_MergeBlessedStackOntoBlessedPieceOverStackSizeTwo" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="62778970" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.020729" asserts="6">
                  <properties>
                    <property name="Description" value="Split-Merge Blessed Stack Onto Blessed Piece Over Stack Size Two" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3++5bF12         |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/cdf35cd1-194b-6b99-2212-15a192c33114.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from e3 onto e5
Accepted: e3-2-e5
-> done: ActionSteps.WhenISplit(Red, "2", E3, E5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on e5
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", E5) (0.0s)
And there should be a red one-stack on e3
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", E3) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1073" name="Split_MergeHappyPath" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeHappyPath" methodname="Split_MergeHappyPath" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1290290304" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.001640" asserts="6">
                  <properties>
                    <property name="Description" value="Split-Merge Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
And the red player splits 1 piece from f2 onto f1
Accepted: f2-1-f1
-> done: ActionSteps.WhenISplit(Red, "1", F2, F1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12kF1+2
Successfully validated 6 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12kF1+2") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1080" name="Split_MergeLeavesCorrectlySizedStacks" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MergeLeavesCorrectlySizedStacks" methodname="Split_MergeLeavesCorrectlySizedStacks" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="877109569" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.004295" asserts="14">
                  <properties>
                    <property name="Description" value="Split-Merge Leaves Correctly Sized Stacks" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board LargeStacks
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b27181cc-4da3-da5d-d8d1-f617dc82b43a.png?raw=true)
Loaded board LargeStacks.
-> done: SetupSteps.GivenIHaveNamedBoard("LargeStacks") (0.0s)
When the red player splits 6 pieces from f2 onto e3
Accepted: f2-6-e3
-> done: ActionSteps.WhenISplit(Red, "6", F2, E3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red fourteen-stack on e3
-> done: ValidationSteps.ThenThereShouldBe(Red, "fourteen", E3) (0.0s)
And there should be a red blessed two-stack on f2
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "two", F2) (0.0s)
When the red player splits 1 piece from d2 onto d1
Accepted: d2-1-d1
-> done: ActionSteps.WhenISplit(Red, "1", D2, D1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red blessed fourteen-stack on d2
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "fourteen", D2) (0.0s)
And there should be a red fifteen-stack on d1
-> done: ValidationSteps.ThenThereShouldBe(Red, "fifteen", D1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1077" name="Split_MoveCannotMoveOntoBlock" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MoveCannotMoveOntoBlock" methodname="Split_MoveCannotMoveOntoBlock" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1471760268" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.024949" asserts="4">
                  <properties>
                    <property name="Description" value="Split-Move Cannot Move Onto Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12+            |
  | B:D78E78k9F78             |
  | X:F3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/711fb733-d785-fbc3-1893-0cc2a94a70b7.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from f2 onto f3
Rejected: f2-1-f3: Stack Size 1 Piece At F2 Cannot Reach F3 (but can reach: F1)
-> done: ActionSteps.WhenISplit(Red, "1", F2, F3) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At F2 Cannot Reach F3 (but can reach: F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1078" name="Split_MoveCannotMoveOverBlock" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MoveCannotMoveOverBlock" methodname="Split_MoveCannotMoveOverBlock" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1606323197" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.022351" asserts="4">
                  <properties>
                    <property name="Description" value="Split-Move Cannot Move Over Block" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12+++          |
  | B:D78E78k9F78             |
  | X:F3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/9214908a-331a-3963-c909-f228add6e256.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from f2 onto f4
Rejected: f2-2-f4: Stack Size 2 Piece At F2 Cannot Reach F4 (but can reach: F1)
-> done: ActionSteps.WhenISplit(Red, "2", F2, F4) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At F2 Cannot Reach F4 (but can reach: F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1076" name="Split_MoveCursesBothPieces" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MoveCursesBothPieces" methodname="Split_MoveCursesBothPieces" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1794295729" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.001684" asserts="7">
                  <properties>
                    <property name="Description" value="Split-Move Curses Both Pieces" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at f1 into f2
Accepted: f1+f2
-> done: ActionSteps.WhenIMerge(Red, F1, F2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
When the red player splits 1 piece from f2 onto f3
Accepted: f2-1-f3
-> done: ActionSteps.WhenISplit(Red, "1", F2, F3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12k3F2c3c
Successfully validated 7 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12k3F2c3c") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1071" name="Split_MoveHappyPath" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.Split_MoveHappyPath" methodname="Split_MoveHappyPath" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1411769179" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.001268" asserts="6">
                  <properties>
                    <property name="Description" value="Split-Move Happy Path" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
When the red player merges the piece at e3 into f2
Accepted: e3+f2
-> done: ActionSteps.WhenIMerge(Red, E3, F2) (0.0s)
And the red player splits 1 piece from f2 onto f3
Accepted: f2-1-f3
-> done: ActionSteps.WhenISplit(Red, "1", F2, F3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D12E12kF12c3c
Successfully validated 7 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D12E12kF12c3c") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1075" name="SplitDistanceCannotExceedSize" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.SplitDistanceCannotExceedSize" methodname="SplitDistanceCannotExceedSize" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="2094255269" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.030103" asserts="20">
                  <properties>
                    <property name="Description" value="Split Distance Cannot Exceed Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D1b+2b+++E1+2k3b+F12b++ |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/243dfa3c-2851-2afd-5fc7-2439d05ea9b3.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from e3 onto e5
Rejected: e3-1-e5: Stack Size 1 Piece At E3 Cannot Reach E5 (but can reach: E4, E2)
-> done: ActionSteps.WhenISplit(Red, "1", E3, E5) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At E3 Cannot Reach E5 (but can reach: E4, E2)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 2 pieces from f2 onto f5
Rejected: f2-2-f5: Stack Size 2 Piece At F2 Cannot Reach F5 (but can reach: F3, F4, F1)
-> done: ActionSteps.WhenISplit(Red, "2", F2, F5) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At F2 Cannot Reach F5 (but can reach: F3, F4, F1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 1 piece from d2 onto d4
Rejected: d2-1-d4: Stack Size 1 Piece At D2 Cannot Reach D4 (but can reach: D3, D1)
-> done: ActionSteps.WhenISplit(Red, "1", D2, D4) (0.0s)
Then the action fails
Failed with: Stack Size 1 Piece At D2 Cannot Reach D4 (but can reach: D3, D1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 2 pieces from d2 onto d5
Rejected: d2-2-d5: Stack Size 2 Piece At D2 Cannot Reach D5 (but can reach: D3, D4, D1)
-> done: ActionSteps.WhenISplit(Red, "2", D2, D5) (0.0s)
Then the action fails
Failed with: Stack Size 2 Piece At D2 Cannot Reach D5 (but can reach: D3, D4, D1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 3 pieces from d2 onto d6
Rejected: d2-3-d6: Stack Size 3 Piece At D2 Cannot Reach D6 (but can reach: D3, D4, D5, D1)
-> done: ActionSteps.WhenISplit(Red, "3", D2, D6) (0.0s)
Then the action fails
Failed with: Stack Size 3 Piece At D2 Cannot Reach D6 (but can reach: D3, D4, D5, D1)
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1074" name="SplitMustRejectInvalidSizes" fullname="Testing.Specflow.Features.GameRules.SplitRulesFeature.SplitMustRejectInvalidSizes" methodname="SplitMustRejectInvalidSizes" classname="Testing.Specflow.Features.GameRules.SplitRulesFeature" runstate="Runnable" seed="1272592068" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.002668" asserts="22">
                  <properties>
                    <property name="Description" value="Split Must Reject Invalid Sizes" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I define board LargeStacks as:
  --- table step argument ---
  | New Game Board                                              |
  | Benediction v1: R-E2 B E8                                   |
  | R:D1b+++++++++++++2b++++++++++++++E1+2k3b+++++++F12b+++++++ |
  | B:D78E78k9F78                                               |
-> done: SetupSteps.GivenIDefine("LargeStacks", <table>) (0.0s)
Given I have board LargeStacks
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b27181cc-4da3-da5d-d8d1-f617dc82b43a.png?raw=true)
Loaded board LargeStacks.
-> done: SetupSteps.GivenIHaveNamedBoard("LargeStacks") (0.0s)
When the red player splits 0 pieces from d2 onto d3
Rejected: d2-0-d3: Must Split At Least One Piece
-> done: ActionSteps.WhenISplit(Red, "0", D2, D3) (0.0s)
Then the action fails
Failed with: Must Split At Least One Piece
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 15 pieces from d2 onto d3
Rejected: d2-15-d3: Must Leave At Least One Piece Behind When Splitting
-> done: ActionSteps.WhenISplit(Red, "15", D2, D3) (0.0s)
Then the action fails
Failed with: Must Leave At Least One Piece Behind When Splitting
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits -47 pieces from d2 onto d3
Rejected: d2--47-d3: Must Split At Least One Piece
-> done: ActionSteps.WhenISplit(Red, "-47", D2, D3) (0.0s)
Then the action fails
Failed with: Must Split At Least One Piece
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 8675309 pieces from d2 onto d3
Rejected: d2-8675309-d3: Must Leave At Least One Piece Behind When Splitting
-> done: ActionSteps.WhenISplit(Red, "8675309", D2, D3) (0.0s)
Then the action fails
Failed with: Must Leave At Least One Piece Behind When Splitting
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player splits 16 pieces from d2 onto d3
Rejected: d2-16-d3: Must Leave At Least One Piece Behind When Splitting
-> done: ActionSteps.WhenISplit(Red, "16", D2, D3) (0.0s)
Then the action fails
Failed with: Must Leave At Least One Piece Behind When Splitting
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1089" name="WinLoseRulesFeature" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" testcasecount="16" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.413755" total="16" passed="16" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="64">
                <properties>
                  <property name="Description" value="Win Lose Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1093" name="BlueCapturingAnyRedKingCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueCapturingAnyRedKingCausesBlueWin" methodname="BlueCapturingAnyRedKingCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1420005430" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.027853" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Capturing Any Red King Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:D123k+F3+H2+            |
  | B:B3kC3kD5+E9F78          |
  | X:B2D4F4                  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/c8116771-c3f4-75f5-bf58-7b447e3a9a69.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at c3 to d3
Accepted: c3d3
-> done: ActionSteps.WhenIMove(Blue, C3, D3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1095" name="BlueFormingChainWithKingCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueFormingChainWithKingCausesBlueWin" methodname="BlueFormingChainWithKingCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="151303544" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.030070" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Forming Chain With King Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B=E8 |
  | R:D123k+E4c5cF5cG2c5cH2c  |
  | B:A1c2cB3k4k5C6D8+E9F8+   |
  | X:B2C7D4F246H3I4          |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/9ea9e8d6-a1d0-4495-c5dc-8d8b3c1e69d9.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player places a piece at d7
Accepted: @d7
-> done: ActionSteps.WhenIDrop(Blue, D7) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1097" name="BlueJoiningKingToExistingChainCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueJoiningKingToExistingChainCausesRedWin" methodname="BlueJoiningKingToExistingChainCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="903611085" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.023772" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Joining King To Existing Chain Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:E3k+I1b2b3b+4c5c        |
  | B:A1c2c3b4b5b+D7k+        |
  | X:E46G36H4                |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/8b800dd1-ec24-16ac-735a-dc4f0f7ef122.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece from d7 to b5
Accepted: d7b5
-> done: ActionSteps.WhenIMove(Blue, D7, B5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1091" name="BlueKingPassingRedWallCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueKingPassingRedWallCausesBlueWin" methodname="BlueKingPassingRedWallCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1427481904" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.025017" asserts="4">
                  <properties>
                    <property name="Description" value="Blue King Passing Red Wall Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:D12F2k+3+H2+            |
  | B:A2k+D5+E9F78            |
  | X:B2D4F4                  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/3f5ddc1e-8e47-da49-a23e-f3ef026b2d9b.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at a2 to a5
Accepted: a2a5
-> done: ActionSteps.WhenIMove(Blue, A2, A5) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1101" name="BlueMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" methodname="BlueMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="552480056" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.023714" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Moving Blessed Piece Onto Blue Home Does Not Cause Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:E3k+G1b+2bI2b4c5c       |
  | B:A1c2c3b4bD7b+F8k+       |
  | X:A5E46G36H4              |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/63866e13-9e9f-89f1-3959-07b948680269.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece from d7 to e8
Accepted: d7e8
-> done: ActionSteps.WhenIMove(Blue, D7, E8) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a blue king on e8 without any blessing
-> done: ValidationSteps.ThenThereShouldBeKingNoSize(Blue, E8) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1100" name="BlueMovingBlessedPieceOntoRedHomeDoesNotCauseWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueMovingBlessedPieceOntoRedHomeDoesNotCauseWin" methodname="BlueMovingBlessedPieceOntoRedHomeDoesNotCauseWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="761515113" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.023946" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Moving Blessed Piece Onto Red Home Does Not Cause Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:F2b7b+G2k+H3bI4c5c      |
  | B:A2c3bB3c5+D2b+F8k+      |
  | X:A5E46G36H4              |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/fa13918f-6e08-68ff-ab7d-e8544d4dc0ca.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves a piece from d2 to e2
Accepted: d2e2
-> done: ActionSteps.WhenIMove(Blue, D2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a blue king on e2 without any blessing
-> done: ValidationSteps.ThenThereShouldBeKingNoSize(Blue, E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1105" name="BlueWinWithNoLegalMovesCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueWinWithNoLegalMovesCausesBlueWin" methodname="BlueWinWithNoLegalMovesCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="2097331654" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.029229" asserts="4">
                  <properties>
                    <property name="Description" value="Blue Win With No Legal Moves Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:A2kD7cE12k78k9cF17c     |
  | B:B3k                     |
  | X:A135C16D358F358G16H2I35 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/f3a2c92e-812c-52dd-ff18-18565b86461e.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece from b3 to a2
Accepted: b3a2
-> done: ActionSteps.WhenIMove(Blue, B3, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1104" name="BlueWithNoLegalMovesCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.BlueWithNoLegalMovesCausesRedWin" methodname="BlueWithNoLegalMovesCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="87850536" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.029530" asserts="4">
                  <properties>
                    <property name="Description" value="Blue With No Legal Moves Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:D7cE12k78k9cF17c        |
  | B:B3k                     |
  | X:A135C16D358F358G16H2I35 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/1e6f0f06-4f4e-8fcd-3feb-04836898d9b3.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece from b3 to a2
Accepted: b3a2
-> done: ActionSteps.WhenIMove(Blue, B3, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1092" name="RedCapturingAnyBlueKingCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedCapturingAnyBlueKingCausesRedWin" methodname="RedCapturingAnyBlueKingCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1972776281" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.030493" asserts="4">
                  <properties>
                    <property name="Description" value="Red Capturing Any Blue King Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:D123k+F3+H2+            |
  | B:B3kC3kD5+E9F78          |
  | X:B2D4F4                  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/a3d29f2e-1f9d-678c-d278-479789a56236.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at d3 to c3
Accepted: d3c3
-> done: ActionSteps.WhenIMove(Red, D3, C3) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1094" name="RedFormingChainWithKingCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedFormingChainWithKingCausesRedWin" methodname="RedFormingChainWithKingCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="112301644" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.022792" asserts="4">
                  <properties>
                    <property name="Description" value="Red Forming Chain With King Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:D123k+E4c5cF5cG5cH5+    |
  | B:B3k4k5+D78+E79F8+       |
  | X:B2C7D4F46               |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/54f2d19a-b7dc-8c06-51c9-e1918c2d789c.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits one piece from h5 to h6
Accepted: h5-1-h6
-> done: ActionSteps.WhenISplit(Red, "one", H5, H6) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1096" name="RedJoiningKingToExistingChainCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedJoiningKingToExistingChainCausesRedWin" methodname="RedJoiningKingToExistingChainCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="273006537" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.021489" asserts="4">
                  <properties>
                    <property name="Description" value="Red Joining King To Existing Chain Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:F2k+I1b2b3b+4c5c        |
  | B:A1c2c4+5+E8k            |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/73e536a4-58dd-be12-6ab9-ca9fb255fb87.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece from f2 to h2
Accepted: f2h2
-> done: ActionSteps.WhenIMove(Red, F2, H2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1090" name="RedKingPassingBlueWallCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedKingPassingBlueWallCausesRedWin" methodname="RedKingPassingBlueWallCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1365041528" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.023877" asserts="4">
                  <properties>
                    <property name="Description" value="Red King Passing Blue Wall Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12I5k          |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/a35f5ddf-3147-68bb-07d0-8fb31d7ae121.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at i5 to a1
Accepted: i5a1
-> done: ActionSteps.WhenIMove(Red, I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1099" name="RedMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" methodname="RedMovingBlessedPieceOntoBlueHomeDoesNotCauseWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="1164541623" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.028808" asserts="4">
                  <properties>
                    <property name="Description" value="Red Moving Blessed Piece Onto Blue Home Does Not Cause Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:F2b7b+G2k+H3bI4c5c      |
  | B:A2c3bB3c5+D2b+F8k+      |
  | X:A5E46G36H4              |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/a01356fd-0b57-499b-9115-447d239b9b15.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves a piece from f7 to e8
Accepted: f7e8
-> done: ActionSteps.WhenIMove(Red, F7, E8) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red king on e8 without any blessing
-> done: ValidationSteps.ThenThereShouldBeKingNoSize(Red, E8) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1098" name="RedMovingBlessedPieceOntoRedHomeDoesNotCauseWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedMovingBlessedPieceOntoRedHomeDoesNotCauseWin" methodname="RedMovingBlessedPieceOntoRedHomeDoesNotCauseWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="649939636" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.027649" asserts="4">
                  <properties>
                    <property name="Description" value="Red Moving Blessed Piece Onto Red Home Does Not Cause Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:C2b+D123E13F12k         |
  | B:C5+D7E7+8kF8+           |
  | X:B6D6F5H3                |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/92ef29dd-3c2d-f1ce-9784-f077e3e82580.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece from c2 to e2
Accepted: c2e2
-> done: ActionSteps.WhenIMove(Red, C2, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a two-stack king on e2 without any blessing
-> done: ValidationSteps.ThenThereShouldBeKingNoColor("two", E2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1103" name="RedWinWithNoLegalMovesCausesRedWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedWinWithNoLegalMovesCausesRedWin" methodname="RedWinWithNoLegalMovesCausesRedWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="946717256" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.023260" asserts="4">
                  <properties>
                    <property name="Description" value="Red Win With No Legal Moves Causes Red Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1k                     |
  | B:A2kD2+E1k2k3c8k9F2c7    |
  | X:B246D168E4F18G35H16I24  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/91ba6995-571f-b17a-cd80-5195f4410037.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece from a1 to a2
Accepted: a1a2
-> done: ActionSteps.WhenIMove(Red, A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1102" name="RedWithNoLegalMovesCausesBlueWin" fullname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature.RedWithNoLegalMovesCausesBlueWin" methodname="RedWithNoLegalMovesCausesBlueWin" classname="Testing.Specflow.Features.GameRules.WinLoseRulesFeature" runstate="Runnable" seed="204956241" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.021411" asserts="4">
                  <properties>
                    <property name="Description" value="Red With No Legal Moves Causes Blue Win" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1k                     |
  | B:D2+E1k2k3c8k9F2c7       |
  | X:B246D168E4F18G35H16I24  |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/46ba263a-50e8-1cad-30a6-9d5e65d65db0.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece from a1 to a2
Accepted: a1a2
-> done: ActionSteps.WhenIMove(Red, A1, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
              </test-suite>
              <test-suite type="TestFixture" id="0-1106" name="WrapAroundRulesFeature" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" testcasecount="21" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:45Z" duration="0.496164" total="21" passed="18" failed="0" warnings="0" inconclusive="3" skipped="0" asserts="95">
                <properties>
                  <property name="Description" value="Wrap Around Rules" />
                  <property name="Category" value="every-change" />
                </properties>
                <test-case id="0-1118" name="BlessedPieceWrappingAroundAndMergingCanFormAnyStackSize" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundAndMergingCanFormAnyStackSize" methodname="BlessedPieceWrappingAroundAndMergingCanFormAnyStackSize" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1565613860" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.024061" asserts="8">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around and Merging Can Form Any Stack Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                        |
  | Benediction v1: R-E2 B E8    |
  | R:A2c++D12E12k3F12G1+7bH6b++ |
  | B:D78E78k9F78                |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/84c371e4-c3dd-4528-e515-1caa429f5727.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at g7 onto g1
Accepted: g7+g1
-> done: ActionSteps.WhenIMerge(Red, G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on g1
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", G1) (0.0s)
When the red player merges the piece at h6 onto a2
Accepted: h6+a2
-> done: ActionSteps.WhenIMerge(Red, H6, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red six-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "six", A2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1125" name="BlessedPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" methodname="BlessedPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1193744683" result="Inconclusive" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.064117" asserts="0">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around and Split Merging Can Form Any Stack Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given this test isn't written yet
-> error: 
]]></output>
                </test-case>
                <test-case id="0-1122" name="BlessedPieceWrappingAroundAndSplittingCompletingBridgeLeavesBless_BlessPair" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundAndSplittingCompletingBridgeLeavesBless_BlessPair" methodname="BlessedPieceWrappingAroundAndSplittingCompletingBridgeLeavesBless_BlessPair" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1775318177" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.019742" asserts="6">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around and Splitting Completing Bridge Leaves Bless-Bless Pair" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G7b+++       |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/d626313b-869a-8237-edf8-f3609360a087.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from g7 onto g1
Accepted: g7-2-g1
-> done: ActionSteps.WhenISplit(Red, "2", G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red cursed two-stack on g7
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", G7) (0.0s)
And there should be a red blessed two-stack on g1
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "two", G1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1121" name="BlessedPieceWrappingAroundAndSplittingLeavesBless_CursePair" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundAndSplittingLeavesBless_CursePair" methodname="BlessedPieceWrappingAroundAndSplittingLeavesBless_CursePair" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1689419232" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.001348" asserts="6">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around and Splitting Leaves Bless-Curse Pair" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G7b+++       |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/d626313b-869a-8237-edf8-f3609360a087.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from g7 onto g1
Accepted: g7-2-g1
-> done: ActionSteps.WhenISplit(Red, "2", G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red cursed two-stack on g7
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", G7) (0.0s)
And there should be a red blessed two-stack on g1
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "two", G1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1113" name="BlessedPieceWrappingAroundMergingOntoHomeBecomesKing" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundMergingOntoHomeBecomesKing" methodname="BlessedPieceWrappingAroundMergingOntoHomeBecomesKing" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1119417134" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.024995" asserts="3">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around Merging Onto Home Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:C1+E2k5+9b+             |
  | B:B6+C3+4k+               |
  | X:A35B2D4                 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/52f1d9c2-59cc-8f43-5f64-989b684fd5f3.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at e9 onto e2
Accepted: e9+e2
-> done: ActionSteps.WhenIMerge(Red, E9, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching C1+E2k++5+
Successfully validated 3 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "C1+E2k++5+") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1112" name="BlessedPieceWrappingAroundOntoHomeBecomesKing" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundOntoHomeBecomesKing" methodname="BlessedPieceWrappingAroundOntoHomeBecomesKing" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="70602216" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.020133" asserts="3">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around Onto Home Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:C1+D2kE5+9b+            |
  | B:B6+C3+4k+               |
  | X:A35B2D4                 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/bee7a4ab-739a-25dd-cce0-af0f6bc8aa5c.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at e9 to e2
Accepted: e9e2
-> done: ActionSteps.WhenIMove(Red, E9, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching C1+D2kE2k+5+
Successfully validated 4 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "C1+D2kE2k+5+") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1109" name="BlessedPieceWrappingAroundRemainsBlessed" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.BlessedPieceWrappingAroundRemainsBlessed" methodname="BlessedPieceWrappingAroundRemainsBlessed" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="2021025989" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.018832" asserts="6">
                  <properties>
                    <property name="Description" value="Blessed Piece Wrapping Around Remains Blessed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
And I add this red piece: I5b
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/4b58034c-f49e-02d9-afaa-c7b264068cc2.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "I5b") (0.0s)
When the red player moves the piece at i5 to a1
Accepted: i5a1
-> done: ActionSteps.WhenIMove(Red, I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: A1bD12E12k3F12
Successfully validated 8 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1bD12E12k3F12") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1116" name="CursedPieceWrappingAroundAndMergingRequiresBlessedTarget" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundAndMergingRequiresBlessedTarget" methodname="CursedPieceWrappingAroundAndMergingRequiresBlessedTarget" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="227872448" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.032464" asserts="7">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around and Merging Requires Blessed Target" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:A4b+D128k++E137cF128c   |
  | B:A1k2cB1k3cC2c3cD7F7     |
  | X:A35B2D46F4H246          |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/baa7ac0a-3f11-78ac-f80a-a2dd502e2eb4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece on f8 to f1
Rejected: f8+f1: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenIMerge(Red, F8, F1) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
When the red player merges the piece on f8 to a4
Accepted: f8+a4
-> done: ActionSteps.WhenIMerge(Red, F8, A4) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching A4++D128k++E137cF12
Successfully validated 9 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A4++D128k++E137cF12") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1123" name="CursedPieceWrappingAroundAndSplitMergingRequiresBlessedTarget" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundAndSplitMergingRequiresBlessedTarget" methodname="CursedPieceWrappingAroundAndSplitMergingRequiresBlessedTarget" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="461380790" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.026354" asserts="4">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around and Split Merging Requires Blessed Target" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G17c+++      |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/0c66e7eb-b20e-e7ae-4355-9c8c70d7940a.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from g7 onto g1
Rejected: g7-1-g1: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ActionSteps.WhenISplit(Red, "1", G7, G1) (0.0s)
Then the action fails
Failed with: Cursed Pieces Can Only Merge With Blessed Pieces
-> done: ValidationSteps.ThenTheActionFails() (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1119" name="CursedPieceWrappingAroundAndSplittingRemainsCursed" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundAndSplittingRemainsCursed" methodname="CursedPieceWrappingAroundAndSplittingRemainsCursed" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="703378036" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.025399" asserts="6">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around and Splitting Remains Cursed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G7c+++       |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/14834f1a-0949-c832-9dfe-9169816ff274.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from g7 onto g1
Accepted: g7-2-g1
-> done: ActionSteps.WhenISplit(Red, "2", G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red cursed two-stack on g7
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", G7) (0.0s)
And there should be a red cursed two-stack on g1
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", G1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1110" name="CursedPieceWrappingAroundOntoHomeBecomesKing" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundOntoHomeBecomesKing" methodname="CursedPieceWrappingAroundOntoHomeBecomesKing" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="189654167" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.024609" asserts="3">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around Onto Home Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D1+3E3k+7c9c+           |
  | B:B4C3+6c7cD68G5k         |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/d973474a-a16c-9a07-4e99-2bb1e850a26d.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece at e9 to e2
Accepted: e9e2
-> done: ActionSteps.WhenIMove(Red, E9, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: D1+3E2k+3k+7c
Successfully validated 5 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "D1+3E2k+3k+7c") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1107" name="CursedPieceWrappingAroundRemainsCursed" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.CursedPieceWrappingAroundRemainsCursed" methodname="CursedPieceWrappingAroundRemainsCursed" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1364427745" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.022246" asserts="6">
                  <properties>
                    <property name="Description" value="Cursed Piece Wrapping Around Remains Cursed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
And I add this red piece: I5c
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b58cce8c-0fb0-0879-1fcd-45fcc2b5395d.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "I5c") (0.0s)
When the red player moves the piece at i5 to a1
Accepted: i5a1
-> done: ActionSteps.WhenIMove(Red, I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: A1cD12E12k3F12
Successfully validated 8 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1cD12E12k3F12") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1127" name="KingStackWrappingAroundAndSplitMergingOntoPieceRemainsBlessedAndWinsGame" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.KingStackWrappingAroundAndSplitMergingOntoPieceRemainsBlessedAndWinsGame" methodname="KingStackWrappingAroundAndSplitMergingOntoPieceRemainsBlessedAndWinsGame" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1628755111" result="Inconclusive" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.003774" asserts="0">
                  <properties>
                    <property name="Description" value="King Stack Wrapping Around and Split Merging Onto Piece Remains Blessed and Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given this test isn't written yet
-> error: 
]]></output>
                </test-case>
                <test-case id="0-1126" name="KingWrappingAroundAndMergingOntoPieceRemainsBlessedAndWinsGame" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.KingWrappingAroundAndMergingOntoPieceRemainsBlessedAndWinsGame" methodname="KingWrappingAroundAndMergingOntoPieceRemainsBlessedAndWinsGame" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1226929871" result="Inconclusive" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.002027" asserts="0">
                  <properties>
                    <property name="Description" value="King Wrapping Around And Merging Onto Piece Remains Blessed and Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given this test isn't written yet
-> error: 
]]></output>
                </test-case>
                <test-case id="0-1115" name="KingWrappingAroundOntoHomeWinsGame" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.KingWrappingAroundOntoHomeWinsGame" methodname="KingWrappingAroundOntoHomeWinsGame" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="885884827" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.030952" asserts="4">
                  <properties>
                    <property name="Description" value="King Wrapping Around Onto Home Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R=E2 B E8 |
  | R:E7+8k++                 |
  | B:B3+6+C1k2k              |
  | X:A35B2D46                |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/539e5cea-5e4f-6fae-2925-ff3447268740.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player moves the piece on e8 to e2
Accepted: e8e2
-> done: ActionSteps.WhenIMove(Red, E8, E2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and red has won
-> done: ValidationSteps.GameOver(Red) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1114" name="KingWrappingAroundOntoRegularSpaceWinsGame" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.KingWrappingAroundOntoRegularSpaceWinsGame" methodname="KingWrappingAroundOntoRegularSpaceWinsGame" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1505942849" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.021380" asserts="4">
                  <properties>
                    <property name="Description" value="King Wrapping Around Onto Regular Space Wins Game" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:E7+H5k++                |
  | B:B6+C1k2k3+              |
  | X:A35B2D4                 |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/29ed879d-c90c-0446-8e3a-c0dc90933b77.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece on c1 to c7
Accepted: c1c7
-> done: ActionSteps.WhenIMove(Blue, C1, C7) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the game is over and blue has won
-> done: ValidationSteps.GameOver(Blue) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1108" name="NormalPieceWrappingAroundBecomesBlessed" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.NormalPieceWrappingAroundBecomesBlessed" methodname="NormalPieceWrappingAroundBecomesBlessed" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1634385680" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.026846" asserts="6">
                  <properties>
                    <property name="Description" value="Normal Piece Wrapping Around Becomes Blessed" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I have board NewGame
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/b50cb248-3720-e98d-f5a2-c04c3545857a.png?raw=true)
Loaded board NewGame.
-> done: SetupSteps.GivenIHaveNamedBoard("NewGame") (0.0s)
And I add this red piece: I5
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/a1573ad0-761c-3260-c032-2f426d00808a.png?raw=true)
-> done: SetupSteps.GivenIAddPieces(Red, "I5") (0.0s)
When the red player moves the piece at i5 to a1
Accepted: i5a1
-> done: ActionSteps.WhenIMove(Red, I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has red pieces matching: A1bD12E12k3F12
Successfully validated 8 Red pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Red, "A1bD12E12k3F12") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1111" name="NormalPieceWrappingAroundOntoHomeBecomesKing" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.NormalPieceWrappingAroundOntoHomeBecomesKing" methodname="NormalPieceWrappingAroundOntoHomeBecomesKing" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="220346557" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.031081" asserts="3">
                  <properties>
                    <property name="Description" value="Normal Piece Wrapping Around Onto Home Becomes King" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board
  --- table step argument ---
  | Board                     |
  | Benediction v1: R E2 B-E8 |
  | R:E2k+3k+47cG4+           |
  | B:B4C6c7cD678E1+H4k       |
  | X:G3                      |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/a1f2b0ad-7167-6a41-119f-db58b3102384.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the blue player moves the piece at e1 to e8
Accepted: e1e8
-> done: ActionSteps.WhenIMove(Blue, E1, E8) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And the board has blue pieces matching B4C6c7cD678E8k+H4k
Successfully validated 8 Blue pieces.
-> done: ValidationSteps.ThenTheBoardHasPiecesMatching(Blue, "B4C6c7cD678E8k+H4k") (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1117" name="RegularPieceWrappingAroundAndMergingCanFormAnyStackSize" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.RegularPieceWrappingAroundAndMergingCanFormAnyStackSize" methodname="RegularPieceWrappingAroundAndMergingCanFormAnyStackSize" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="112203528" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:44Z" duration="0.029985" asserts="8">
                  <properties>
                    <property name="Description" value="Regular Piece Wrapping Around and Merging Can Form Any Stack Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                      |
  | Benediction v1: R-E2 B E8  |
  | R:A2c++D12E12k3F12G1+7H6++ |
  | B:D78E78k9F78              |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/efee6de3-9e9c-985e-0628-cdc038d37d8b.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player merges the piece at g7 onto g1
Accepted: g7+g1
-> done: ActionSteps.WhenIMerge(Red, G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red three-stack on g1
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", G1) (0.0s)
When the red player merges the piece at h6 onto a2
Accepted: h6+a2
-> done: ActionSteps.WhenIMerge(Red, H6, A2) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red six-stack on a2
-> done: ValidationSteps.ThenThereShouldBe(Red, "six", A2) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1124" name="RegularPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.RegularPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" methodname="RegularPieceWrappingAroundAndSplitMergingCanFormAnyStackSize" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="1011286350" result="Passed" start-time="2020-02-08 19:21:44Z" end-time="2020-02-08 19:21:45Z" duration="0.023509" asserts="6">
                  <properties>
                    <property name="Description" value="Regular Piece Wrapping Around and Split Merging Can Form Any Stack Size" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:A1+D12E12k3F12I5+       |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/8de9cecb-7517-e470-faee-b8ed424e74e4.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 1 piece from i5 onto a1
Accepted: i5-1-a1
-> done: ActionSteps.WhenISplit(Red, "1", I5, A1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red one-stack on i5
-> done: ValidationSteps.ThenThereShouldBe(Red, "one", I5) (0.0s)
And there should be a red three-stack on a1
-> done: ValidationSteps.ThenThereShouldBe(Red, "three", A1) (0.0s)
]]></output>
                </test-case>
                <test-case id="0-1120" name="RegularPieceWrappingAroundAndSplittingLeavesBless_CursePair" fullname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature.RegularPieceWrappingAroundAndSplittingLeavesBless_CursePair" methodname="RegularPieceWrappingAroundAndSplittingLeavesBless_CursePair" classname="Testing.Specflow.Features.GameRules.WrapAroundRulesFeature" runstate="Runnable" seed="2109232413" result="Passed" start-time="2020-02-08 19:21:45Z" end-time="2020-02-08 19:21:45Z" duration="0.021267" asserts="6">
                  <properties>
                    <property name="Description" value="Regular Piece Wrapping Around and Splitting Leaves Bless-Curse Pair" />
                  </properties>
                  <output><![CDATA[Given I define board NewGame as:
  --- table step argument ---
  | New Game Board            |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12             |
  | B:D78E78k9F78             |
-> done: SetupSteps.GivenIDefine("NewGame", <table>) (0.0s)
Given I load this board:
  --- table step argument ---
  | Board                     |
  | Benediction v1: R-E2 B E8 |
  | R:D12E12k3F12G7+++        |
  | B:D78E78k9F78             |
![Board Snapshot](https://raw.githubusercontent.com/MichaelSpencerJr/BenedictionGame/master/testruns/images/ae297736-9a54-9011-f334-4c1856a8fd9e.png?raw=true)
-> done: SetupSteps.GivenILoad(<table>) (0.0s)
When the red player splits 2 pieces from g7 onto g1
Accepted: g7-2-g1
-> done: ActionSteps.WhenISplit(Red, "2", G7, G1) (0.0s)
Then the action succeeds
-> done: ValidationSteps.ThenTheActionSucceeds() (0.0s)
And there should be a red cursed two-stack on g7
-> done: ValidationSteps.ThenThereShouldBeCursed(Red, "two", G7) (0.0s)
And there should be a red blessed two-stack on g1
-> done: ValidationSteps.ThenThereShouldBeBlessed(Red, "two", G1) (0.0s)
]]></output>
                </test-case>
              </test-suite>
            </test-suite>
          </test-suite>
        </test-suite>
      </test-suite>
    </test-suite>
  </test-suite>
</test-run>